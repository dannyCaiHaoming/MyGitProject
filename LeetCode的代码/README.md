# MyLeetCode

`Todo:`将每道算法题的思路记录下来 

### 5.最大回文子串

- 题解1：
	- 动态规划，重要思想是，大问题能分成小问题，然后这些分出来的小问题，都是能由最小的小问题重叠起来。这题可以遍历回文串，先找出"aa","aba"的情况记录下来，由于使用的是i,j两层遍历，因此能遍历到的串会原来越长，这时候再次找到s[i]==s[j]的时候就可以分解去判断小问题(子串是否回文)，然后继续记录

- 题解2：
	- 中心扩展。对于每一位数(取一位，跟取其后面一位作为两位)，开始中心扩展找回文长度，每次就是对比`l-1`跟`r+1`是否相等

### 8.字符串转换整数 (atoi)

- 思路：
	- 先把头尾的“ ”移除，如果有异常则退回0
	- 把开头的符号位记录下，然后从符号位下一位开始
	- 遍历正确的字符串，以`res = res*10+str[i]`作为结果
	- 将符号位跟结果是否溢出，得出溢出的两个结果
	- 最后的结果是符号位*结果

### 171.Excel表列序号
```
    思路：将每一位字符串取出来，然后转成数字第0位乘26的0次方，第1位乘26的1次方...
```

### 172.阶乘后的零
```
    思路：由于两个最小数的乘积能得到10，就是2和5，由于阶乘中，能分解出2的数绝对会比能分解出5的数要多得多，因此，这道题就是要算出5的个数
```

### 189.旋转数组

- 我先想到的是，将两个一样的数组拼好，然后根据移动的距离%数组的长度，就能得到实际需要后第二段开始往前位移多少位，然后根据数组长度就能得到最后数组。
    
- 题解：暴力旋转，每一步都将数组旋转
    
- 题解：暴力旋转的时候，我们做的是将整个数组连续的往前往后的移动，其中需要满足连续，并且使用temp变量。暴力仅能满足每次移一位，其中会初夏你很多重复的操作。当我们不想增加空间的时候，并且希望减少重复移动。我们就将整个数组分组成k段，每次使用n/k个元素为一组进行暴力移动，这样确保了不会有重复的移动操作。


### 516.最大回文子序列

- 题解1：
	- 动态规划，跟[5.最大回文子串]()类似。不过这里由于是求**回文子序列，而不是子串**，因此只需要保证找到s[i]==s[j]，记录下dp[i][j]这段序列中最大的回文长度，下次找到s[i-1]...s[j+1]回文长度就会等于2+dp[i]s[j]的长度
	- 核心思想还是，小聚大，从下往上求解（可能出现的疑惑是，一串很长的回文串是怎么算出长度？回文串如果分成前一段后一段的情况又是如何计算得？）
		- 长的回文串，其实就是用它的子串回文长度+2就是了
		- 沿用大串其实是用子串的回文长度的思想，如果当出现一个大串不相等的时候，这个串中最大的子串就还是他内部的最大子串（这里可以假想中间有一个回文子序列，然后扩增这个串，每次有出现一对儿的才能认为回文子序列会增加）
