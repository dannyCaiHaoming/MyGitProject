## UI视图相关

### 1. UITableView相关

#### 1.1 重用机制
就是TableView会使用一个叫`重用池`，当屏幕显示`TableViewCell`的时候，会去这个`重用池`去拿，如果`重用池`没有的时候，就会新建一个`TableViewCell`；当这个`TableViewCell`移出屏幕，当前不显示的时候，就会被放入`重用池`，等待下次有需要使用的时候，直接从`重用池`去拿，减少创建的消耗。

#### 1.2 数据源同步问题
实际场景，就是当进行网络操作`LoadMore`的过程中，进行了一些删除的操作，就需要进行数据源同步的处理。

- 1.并发访问、数据拷贝
  - 会把进行在`子线程`进行网络请求前的数据进行一份`拷贝`，用于在请求异步过程中记录在`主线程`对数据做的一些增删改查操作。然后在网络请求回来之后，对比两份数据，然后也将记录的操作在拷贝的数据上进行，然后再做UI更新的操作。
	
- 2.串行访问
 - 使用一个`串行队列`，将`主线程`中的操作，以及`子线程`中的网络请求，都放入`串行队列`中。`串行队列`的任务会依据先来先执行的规则。但是由于是在`串行队列`中，如果有占用时长大的任务，会造成数据返回到`主线程`更新有延迟。


### 2. UIView和CALayer
简单来说，应用`单一职责`的设计原理，将功能区分开，`UIView`用于传递绘制内容给`CALayer`并且由于继承自`UIResponder`，因此还具有响应触碰的；`CALayer`只是单纯的用于生成展示的内容（`content`其实也是最终的`位图`）。

有个比喻很好：**UIView是一副PS的图，而实际这个图上面是有很多个图层叠加而成的，这里面的图层其实就是CALayer**

- `UIView`其实只是一个容器，用于装载`CALayer`.**二者之间绘制的关系需要了解，这样在使用`CoreGraphics`做一些绘画的时候，才能做到用的明白**
- `UIView`实际只是通过传递内容给`CALayer`，通过`CALayer`绘图。
- `UIView`的frame决定了`CALayer`的可视空间


#### 2.1 CALayer是怎样显示的（位图）
- `CALayer`有一个`contents`属性，通过赋值，可以在图层上显示你想要显示的图片。
- 你也可以自行绘图，然后经过处理之后最终也会变成类似`图片`，

#### 2.2 绘制方法
- `CALayer`自带方法
	- `func display(_ layer: CALayer)` 可以重写该方法，主要用于设置`contents`属性
	- `func draw(_ layer: CALayer, in ctx: CGContext)`可以获取`context`，更加丰富的绘制入口

- `CALayerDelegate`
如果自带的方法没有实现，则可以使用`delegate`的方法
	- `func display(_ layer: CALayer)` **异步绘制的入口**
	- `func draw(_ layer: CALayer, in ctx: CGContext)`

#### 2.3 绘制时机


#### 2.4 异步绘制
