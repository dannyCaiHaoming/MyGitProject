# 包体瘦身

##  瘦身的方向
app分为bundle和可执行文件(mach.o)。
1. bundle资源压缩可去重
2. 可执行文件，代码去重
3. 项目一些配置


## mach-o格式 
mach-o文件是Mach object的缩写，是mac、ios上用于存储程序、库的标准格式。
目标文件是代码文件和可执行文件的中间产物。 .c -> .o -> 可执行文件

- 目标文件(.o)，
- 静态库文件(.a)，静态库其实就是n个.o合并在一起


## 瘦身的方式


### 1. 对目标文件mach-o进行瘦身，主要是分析link map文件对没有引用的到的方法，类名进行优化。
效果不太多（类减少几十个大概几百KB，方法几千个大概几MB）
1. 排查无用类
2. 排查无用方法

```
1. 可以使用编译器选项，link map，生成一个linkmap的文件。有一个python的脚本，`linkmap-analyse`。这个linkmap文件，相当于描述了目标文件mach-o中的TEXT段和DATA段数据的开始地址及大小。其中就有TEXT段中所有的类和所有的方法列表，以及DATA段中实际引用到的类和方法列表。可以实现一个脚本读取这个linkmap文件，读取<Section>中，"__TEXT __objc_classname","__TEXT __ojbc_methname"获取代码段中所有的类名还有方法名的开始地址（全），"__DATA __objc_classrefs","__DATA __objc_selrefs"获取数据段中程序中用到的类和方法列表（局部），然后根据开始和大小，在<Symbols>中截取，用全-局部就得到多余的部分。

2. 我们也可以使用otool -s -v '字段名'命令获取目标文件中的字段。然后后续分析和1一样。
```

### 2. 资源进行压缩

1. 先删除重复无用的资源！
2. 对asset catlog的资源进行压缩

```
1. png进行无损压缩和，由于苹果对png文件有额外的压缩策略，因此无效。只能对jpg文件进行压缩。
```
3. 对bundle的资源进行压缩

```
可以实现的策略：
1. 在编译的时候使用脚本对需要压缩的资源，进行压缩
2. 然后在应用内，在合适的时机进行解压到沙盒中
3. 并且对应用内使用资源的方法进行调整。
    a. 对资源先从bundle查找
    b. 然后到沙盒指定路径查找
    c. 额外增加一个到服务器下载的逻辑，可以为一些资源迁移到服务器的时候增加适用性

```

### 3. 编译选项优化

1. `LTO`， link-time optimization 
- 将函数内联化
- 去除一些无用的代码
- 对程序有全局优化的作用

能减少安装包的大小，但是由于会去除无用的代码(亲测method swiziling会无效)

2. 使用`-Oz`编译参数
原理是对重复的连续机器指令外联成函数进行复用

3. 修正`Exported Symbols`配置
`EXPORTED_SYMBOLS_FILE`配置，控制着mach-o中的__LINKEDIT中的Export Info信息。动态连接器dyld在做符号表绑定石，会读取被绑定的动态库或可执行文件的Export Info信息，得到一个符号对应的实际调用地址。</br>
虽然Export Info看似不可或缺，但是对于Mach_o来说，并非所有符号都需要暴露。即可以通过`Export Symbols`配置白名单，在动态库或可执行文件在静态链接时就不理会白名单的内容，缩小包的体积。

### 4. 苹果提供的

1. Slicing

2. Bitcode

3. On-Demand Resources

## 反思优化

### 1. 属性优化
