Geniust art：

1.项目编辑页架构 代码优化





【如何进行抠像的】

​	这边主要是使用到了公司大数据团队提供的一个深度学习模型。我们在项目里面使用这个人像分割模型处理人像图片后得到的是一个人像区域的灰度图，即人像区域的像素值会大于0.根据这个特征我们只需要将这个灰度图作为mask图，跟原图进行一个mask blend操作，即可以将人像区域图像分离出来。





​	编辑页，是将一个人像抠图然后进行一些修图效果的页面。基本的功能就有模板，滤镜，替换背景，增加贴纸，发型等等。在第一版需求的时候，就有一个可以将效果进行前进后退的要点，于是当时就使用了命令模式进行对这些功能进行抽象。

【这里需要展开吗？—怎么抽象法】

​	每一个功能，其实就是根据输入的原料，经过处理后得到最终的一些结果图。例如背景图，就是直接输入背景图得到背景图。滤镜就是输入滤镜参数，以及要处理的图层，然后输出结果图层。最后将结果应用到现有的图层上。

代码是怎么写的：

​	定义一个Command的协议，里面带有一个infos字典类变量，用于传递各个命令中用到的原料，一个事件接收者（主要是维护图层，更新备份等），用于接收每个命令应用后的更新，主要是维护各个展示图层。然后定义一个excute方法接口， 用于外部调用者统一执行。例如一个替换背景的动作，即会创建一个更新背景的Command，然后将原料即新背景图，然后还有一个事件接收者。当执行这个命令的时候，就会从接收者上面获取当前的图层，筛选出背景图，然后将新的背景图插入到原来的背景图的顺序中。如果当用户确认了这个效果之后，外部维护的命令栈，才会最终将这个命令入栈，否则只是更新了接收者以及视图上的内容。当用户取消这个背景替换操作的时候，会重新将栈顶的命令拿出来重新执行以达到恢复原状的效果。







【如何找到需要更换的图层？】

每个图层使用一个object对应初始化，而每个object在创建的时候会唯一赋予一个udid，而这个图层也会有一个和这个object一样的id



【那你后面是有别的处理？】

​	是的，基于前期的一些功能开发，以及后面对一些耗时功能（例如艺术滤镜）在前进后退效果上会有让用户等待的体验不好的情况。于是，还是基于命令模式，但是抽象的对象由图片生成过程变成了图片变化的过程。例如：之前命令是负责提供背景图生成，艺术滤镜生成，但是现在只是负责图的增删变化。这样子在遇上耗时的效果前进后退的时候，也能直接快速展示变化，唯一的缺点就是可能图层原来越多，耗费的内存会越来越大。因此这个后来也对保存命令栈有个数量上限的限制。

那这里是怎么实现的呢？

​	只定义了增加、删除、更新的命令。但是现在的命令和功能的实现分离开。使用工厂模式，定义一个接口，输入的是功能的原料，输出的是处理完的结果图层。例如背景功能，需要的使用一个新的背景图，然后结果就是输出这个背景的的图层。然后依据不同功能的特点例如背景图、艺术滤镜等是替换，贴纸发型这类是添加，将输出的图层应用到原有的图层上。再用户确认之后，会根据现有的图层，生成一个UpdateCommand，并且将这个UpdateCommand入栈。

【前后对比？】

​	命令模式的内容，由保存每一步工功能的实现，变成保存每一步的所有图层。增加了内存的消耗，但是降低了在前进后退中可能存在耗时等待的不好体验。



【命令模式：】

将实现相关的主体、原料和实现抽象出来。让调用者使用的时候摆脱过多实现的细节。由于将每个操作都抽象出来当做一个命令，因此可以使用栈的结构将每个命令存储起来，实现前进后退的效果。



【抽象工厂模式、工厂模式区别：】

先说工厂模式，就是将生成产品的过程，以及最终生成的产品抽象，对于调用方来说过程和结果是透明的，将过程及结果放到子类实现和决定。

抽象工厂模式，就是工厂模式的一个复数(英语的那个复数)形式。一个抽象出来的工厂可以生产几个不同的产品，并且这些过程和结果也是对于调用者来说是透明的。





2.橡皮擦画笔 基于CoreGraphics实现画笔橡皮擦自定义画笔功能

有没有其他技术可以实现。为什么不使用其它技术？性能对比，为啥CALayer的方案有问题

CoreAnimation，CoreGraphics，或者更底层的Metal，OpenGL。





1.怎么记录用户手指移动的轨迹

2.如何将轨迹绘制出来

3.性能怎么样，为什么没有选用另外CoreAnimation，为啥会卡，原因是什么。看是用图层增加的方式，还是点增加重新绘制的方式。



【为什么没有使用CoreAnimation，或者OpenGL】



【怎么实现橡皮擦的？】

​	应用中有两处地方应用到了橡皮檫。一个是使用抠图模型把人脸从图像上扣下来的时候，识别效果和边缘效果不是很好。第二个是画笔功能中。

【两个功能都说一下】





​	首先考虑怎么记录用户轨迹，我选用的是使用UIView提供的响应事件API，根据用户的touchBegan，touchMove，touchEnd，来生成开始的点，移动的点，以及开始绘制的时机。我使用的是UIBezierth曲线来提供用户的轨迹，这个能提供生成比较圆润的拐点。

​	UIBezierth曲线先在UIView相应touchBegan的时候moveToPoint建立开始点，然后在每个touchMove的时候获取到用户手势移动途径上的点（这个点其实是不能非常实时的，如果用户移动的特别快的话），然后对当前的UIBezierth曲线addLine。最后在用户移动结束touchEnd的时候，调用setNeedsDisplay调起UIView的绘制流程。



【怎么生成擦除区域的内容，怎么给内容补充】

 首次进来，是根据人像原图，和一张一样大小的色块图，我们app的主色调是一个红色，所以就先绘制了一张红色色块图，然后将这个色块图和人像图进行mask操作。这里是色块图是原图，mask的图是人像图，我需要根据人像图生成一个人像区域大小的一个色块来指示当前可以擦除的区域是如何。这里需求是这个人像指示的区域是要有点透明的，我并没有对这个色块加上这个透明度，而是简单的对展示这个色块指示区域的view给了透明度，这样子方便在后面用画笔增加区域的时候，要另外用混合模式（另外用使用结果作为输出的函数）。然后在每次增加指示区域，或者擦除指示区域的时候，创建一个上下文context，然后将上一次的结果图片，先绘制到context上面，然后根据手势开始移动生成的UIBezierPath，根据是增加还是擦除，使用普通的混合模式还是clear的混合模式以及透明的笔画还是红色笔画，达到画画或者擦除。然后在结束的时候，根据现在context的内容生成一个结果图片。



【这里的混合是怎么处理的？GPUImage3相关的一些问题】



【UIView的绘制流程说一下？】

​	

​	在UIView绘制流程，及进入draw(layer inctx:)的方法。在拿到上下文context之后，根据用户移动途径生成的UIBeizerPath曲线，如果是普通画笔就是用有颜色的进行stroke，且strokeBlend模式为普通，及正常的图层叠加效果。如果是橡皮擦的话，就把stroke的颜色设置为clear，且storkeBlend模式为clear，这样子就会把混合结果清除。

​	然后我这里是选择了每次绘制完，将这个上下文生成一个图片的方案。

【为什么这样子处理呢？如果我后面让你做一个绘画板，每画一笔也是生成一个图片？】

​	



3.自定义画笔绘制

4.使用Metal将深度图片立体化

4.内购优化

5.公司需求



1. 负责项目编辑页架构设计及后期代码架构和功能优化，具体应用到命令模式和工厂模式
2. 使用CoreGraphics实现橡皮擦与画笔功能
3. 实现自定义线段绘制功能
4. 使用Metal实现深度图片立体化效果
5. 优化内购订阅，避免了重复购买的情况
6. 负责公司商业化需求（付费页、a/b下发业务逻辑），重构订阅页流程，降低后续开发复杂度





小组件：

Ui样式，展示刷新逻辑



arKit：



AVFoundation