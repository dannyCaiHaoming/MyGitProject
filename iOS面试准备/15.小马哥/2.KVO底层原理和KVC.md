 面试题：

- iOS用什么方式实现对一个对象的KVO（KVO的本质是什么）
- 如何手动触发KVO
- 通过KVC修改属性会触发KVO吗
- KVC的赋值和取值的过程是怎么样的？原理是什么？



### 1. KVO

KVO的全称是key-value-observing，俗称键值监听，可以用于监听某个对象属性值的改变。



#### 1.1 KVO一般使用

```objective-c
- (void)addObserver{
  self.person = [[Person alloc] init];
  // 添加监听器
	[self.person addObserver: self forKeyPath:@"age" option:new | old context:nil];
  self.person.age = 10;
}

- (void)dealloc {
  // 移除监听器
	[self.person removeObserver:self forKeyPath:@"age"];
}

// 监听到keypath的值变化得到方法调用
- (void)observerValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyvalueChangeKey,id>change context:(void *)context){
  // 输入option的内容，change的字典里面告诉我们选项传入的内容。
}


```

#### 1.2 KVO的本质

当我们为一个对象添加一个KVO的时候，Runtime会为我们动态生成一个`NSKVONotifying_XXX`的类对象，这个类是继承于原来的类。然后将这个对象的`isa` 指针指向这个新建的类。

```objc
// 动态新建的子类中
//复写原来的setter方法
// 实际调用Foundation中的_NSSet**ValueAndNotify
- (void)setAge:(int)age {
  _NSSetIntValueAndNotify();
}

void _NSSetIntValueAndNotify() {
  [self willChangeValueForKey@"age"];
  [super setAge: age];
   [self didChangeValueForKey@"age"];
}

- (void)didChangeValueForKey: (NSString *)key {
  // 调用监听器的方法，通知值发生变化
  [observer observerValueForKeyPath: key ofObject: object change:nil context:nil];
}


```

动态生成的子类`NSKVONotify_XXXX`勒种，包含了属性的setter方法，dealloc方法，isKVOA方法，以及class方法。重写class方法，为了屏蔽内部实现，在外部查看的时候，还是返回原来的类型。

<img src="../images/15/KVO本质.awebp" style="zoom:67%;" />



##### 1.2.1 打印所有方法

```objc
- (void)printAllMethodNameOfClass: (Class)cls {
	unsigned int count;
  Method *methodList = class_copyMethodList(cls,&count);
  for (int i = 0; i < count; i++) {
    Method method = methodList[i];
  }
  free(methodList);
}
```



#### 1.3 _NSSet**ValueAndNotify内部

- 调用willChangeValueForKey
- 调用原来类的setter方法([super setAge:age])
- 调用didChangeValueForKey：内部会调用observer的observerValueForKeyPath:ofObject:change:context方法



#### 1.4 KVO崩溃

**被观察者在销毁前，要移除所有的观察者，iOS10以下会崩溃，iOS11以上不会崩溃**

##### 1.4.1 崩溃的原因

- observer没有写回调方法observerValueForKeyPath,因为需要在didChangeValueForKey中调用的。

- add和remove次数不匹配

  - 多次移除
  - vc内观察者一个label，当vc推出页面前，没有remove。iOS11以后就不会了。
  - vc内观察一个label，label提前释放了，导致页面退出时，无法调用成功remove方法.

  

##### 1.4.2 解决的方案

主要的思路就是，解决观察者与被观察对象之间dealloc时间不对等造成remove不成功的情况。



1. 使用了一个对象进行存储target，observer，
2. 在观察者与被观察者上添加关联对象，这样子无论观察者还是被观察者释放的时候，关联对象也会同样得到释放
3. 关联对象释放的时候，使用存储的target，observer进行remove操作。





### 2. KVC

KVC的全称是Key-value Coding，俗称键值编码，可以通过一个key来访问某个属性。

```objc
//常见的API
- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;
- (void)setValue:(id)value forKey:(NSString *)key;
- (id)valueForKeyPath:(NSString *)keyPath;
- (id)valueForKey:(NSString *)key;

//setValue:forKeyPath:和setValue:ForKey:的区别
[person setValue:@10 forKey:@"age"];
//person对象里面有一个cat对象，可以通过keypath来修改cat里面的属性值
[person setValue:@10 forKeyPath:@"cat.weight"];
```



#### 2.1 KVC底层实现

具体思路是需要在被观察对象dealloc的时候，及时使用被观察者去调用removeObserver:forKeyPath。

```objc
#import <Foundation/Foundation.h>

@interface NSObject (ObserverHelper)

- (void)cc_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;

@end

#import "NSObject+ObserverHelper.h"
#import <objc/message.h>

@interface ObserverHelper : NSObject
@property (nonatomic, unsafe_unretained) id target;
@property (nonatomic, unsafe_unretained) id observer;
@property (nonatomic, strong) NSString *keyPath;
@property (nonatomic, weak) ObserverHelper *factor;
@end

@implementation ObserverHelper
- (void)dealloc {
    if ( _factor ) {
        [_target removeObserver:_observer forKeyPath:_keyPath];
    }
}
@end

@implementation NSObject (ObserverHelper)

- (void)cc_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath {
    [self addObserver:observer forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:nil];
    
    ObserverHelper *helper = [ObserverHelper new];
    ObserverHelper *sub = [ObserverHelper new];
    
    sub.target = helper.target = self;
    sub.observer = helper.observer = observer;
    sub.keyPath = helper.keyPath = keyPath;
    helper.factor = sub;
    sub.factor = helper;
    
    const char *helpeKey = [[keyPath mutableCopy] UTF8String];
    const char *subKey = [[keyPath mutableCopy] UTF8String];
    // 关联属性  举例 self 和 helper 关联 当self释放的时候 helper释放 即可释放self的kvo 观察者和sub关联 当观察者释放的时候 调用sub的移除同样也能删除self的kvo   factor是同一个对象 是为防止多次移除导致的崩溃
    objc_setAssociatedObject(self, helpeKey, helper, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    objc_setAssociatedObject(observer, subKey, sub, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

@end
```





##### 2.2.1 setValue:forKeyPath原理

![](../images/15/setValueForKey原理.awebp)

- setkey方法

- _setKey方法

- 访问accessInstanceVariablesDirectly方法

  - _key
  - _isKey
  - key
  - isKey

  直接修改成员变量的值，是不会触发KVO的，因为KVO的底层原理是通过调用重写的setter方法来调用observer的通知方法的。

  但是如果通过调用KVC来修改属性值或者成员变量的值，是可以触发KVO的，因为KVC的底层也会先尝试去调用setter方法的。此外，属性如果没有找到setter方法，但是允许直接访问成员变量的话，会按照 \_key,_isKey,key,isKey的查找顺序去找到成员变量，并且在设置值的前后调用willChangeValueForKey,和didChangeValueForkey。成员变量的话就会直接跳过找setter方法这步。



##### 2.2.2 valueForKey的原理

![](../images/15/valueForKey的原理.awebp)

- 先查找getter方法
  - getKey
  - key
  - isKey
  - _key
- 查找成员变量
  - _key
  - _isKey
  - key
  - isKey



### 面试题答案

#### 1. 

- 利用Runtie的API动态生成一个子类，并且让实例对象的isa指针指向这个全新的类。
- 当修改实例对象的属性的时候，会调用`Foundation`的`_NSSet*ValueAndNotify`函数
  - 这个函数会调用`willChangeValueForKey`
  - 调用原来类中的`setter方法`
  - 调用`didChangeValueForkey`
    - 内部会触发observer的`observerValueForKeyPath:ofObject:change:context`方法

#### 2.

- 调用willChangeValueForkey
- 调用值的更新
- 调用didChangeValueForkey

必须成对出现，如果不调用willChangeValueForKey，则后面的didChangeValueForKey不会生效。

