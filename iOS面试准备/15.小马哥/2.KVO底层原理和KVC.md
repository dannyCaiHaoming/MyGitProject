面试题：

- iOS用什么方式实现对一个对象的KVO（KVO的本质是什么）
- 如何手动触发KVO



### 1. KVO

KVO的全称是key-value-observing，俗称键值监听，可以用于监听某个对象属性值的改变。



#### 1.1 KVO一般使用

```objective-c
- (void)addObserver{
  self.person = [[Person alloc] init];
  // 添加监听器
	[self.person addObserver: self forKeyPath:@"age" option:new | old context:nil];
  self.person.age = 10;
}

- (void)dealloc {
  // 移除监听器
	[self.person removeObserver:self forKeyPath:@"age"];
}

// 监听到keypath的值变化得到方法调用
- (void)observerValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyvalueChangeKey,id>change context:(void *)context){
  // 输入option的内容，change的字典里面告诉我们选项传入的内容。
}


```

#### 1.2 KVO的本质

当我们为一个对象添加一个KVO的时候，Runtime会为我们动态生成一个`NSKVONotifying_XXX`的类对象，这个类是继承于原来的类。然后将这个对象的`isa` 指针指向这个新建的类。

```objc
// 动态新建的子类中
//复写原来的setter方法
// 实际调用Foundation中的_NSSet**ValueAndNotify
- (void)setAge:(int)age {
  _NSSetIntValueAndNotify();
}

void _NSSetIntValueAndNotify() {
  [self willChangeValueForKey@"age"];
  [super setAge: age];
   [self didChangeValueForKey@"age"];
}

- (void)didChangeValueForKey: (NSString *)key {
  // 调用监听器的方法，通知值发生变化
  [observer observerValueForKeyPath: key ofObject: object change:nil context:nil];
}


```

动态生成的子类`NSKVONotify_XXXX`勒种，包含了属性的setter方法，dealloc方法，isKVOA方法，以及class方法。重写class方法，为了屏蔽内部实现，在外部查看的时候，还是返回原来的类型。

<img src="../images/15/KVO本质.awebp" style="zoom:67%;" />



##### 1.2.1 打印所有方法

```objc
- (void)printAllMethodNameOfClass: (Class)cls {
	unsigned int count;
  Method *methodList = class_copyMethodList(cls,&count);
  for (int i = 0; i < count; i++) {
    Method method = methodList[i];
  }
  free(methodList);
}
```



#### 1.3 _NSSet**ValueAndNotify内部

- 调用willChangeValueForKey
- 调用原来类的setter方法([super setAge:age])
- 调用didChangeValueForKey：内部会调用observer的observerValueForKeyPath:ofObject:change:context方法





### 面试题答案

#### 1. 

- 利用Runtie的API动态生成一个子类，并且让实例对象的isa指针指向这个全新的类。
- 当修改实例对象的属性的时候，会调用`Foundation`的`_NSSet*ValueAndNotify`函数
  - 这个函数会调用`willChangeValueForKey`
  - 调用原来类中的`setter方法`
  - 调用`didChangeValueForkey`
    - 内部会触发observer的`observerValueForKeyPath:ofObject:change:context`方法

#### 2.

- 调用willChangeValueForkey
- 调用值的更新
- 调用didChangeValueForkey

必须成对出现，如果不调用willChangeValueForKey，则后面的didChangeValueForKey不会生效。

