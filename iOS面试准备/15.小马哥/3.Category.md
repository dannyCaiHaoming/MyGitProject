面试题：

- Category的使用场景
- Category的实现原理
- Category和extension的区别是什么
- Category中有load方法吗？load方法什么时候调用？load方法能继承吗？
- load、initialze方法的区别是什么？他们在category中的调用顺序？以及出现继承时他们之间的调用顺序？
- Category能否添加成员变量？如果可以，如何添加成员变量？



### 1. Category的底层结构 

category其实底层是一个`category_t`的结构体，里面包含了:

- name
- class
- 对象方法列表
- 类方法列表
- 属性列表
- 协议列表

里面是没有成员变量列表的，因为分类中不允许添加成员变量的。

分类中添加的属性并不会为我们生成成员变量，只会生成`setter`和`getter`方法的声明，实现需要我们自己来。

<img src="../images/15/category底层.awebp" style="zoom: 33%;" />





### 2. 分类中的对象方法列表最终会存放在类对象里，类方法会存在元类对象里

合并过程是：

- 编译器加载所有类和分类信息
- 在程序运行过程中，找到某一个类的分类列表，遍历每一个分类信息，取出他们里面的方法列表，属性列表，协议列表，分别加入对应的二位数组里面，这里注意是从后往前遍历的。所以先编译的分类的信息会加载二维数组的后面。
- 通过类对象的data()方法，找到类对象的`class_rw_t`结构体，class_rw_t中存放着类对象的方法，属性，和协议等数据。然后将刚才的二位数组的元素一一插入到原来方法列表的最前面。(系统内部用memmove将原来的方法列表往后移动，使用memcopy将分类的方法数组copy到方法数组前面)所以分类重写本类方法的时候，会覆盖本类的方法，本质是优先调用。





### 3. category实现的原理，以及为什么只能添加方法，不能添加属性

category的实现原理是将category里面的方法、属性、协议数据放在category_t的结构体中，然后将结构体中的方法列表拷贝到类对象的方法列表中。category可以添加属性，但是并不会自动生成成员变量以及setter、getter方法的实现。因为category_t结构体重并不存在成员变量。通过OC对象的本质，实例对象底层结构体，alloc后，内存空间就申请完了，固定了，内存大小和成员变量相关的，所以不能增加成员变量。但是可以通过Runtime的API关联对象来间接实现这个功能。



### 4. category和extension的区别

extension是在编译时就把数据包含在类信息中，category是在运行时才会把数据合并到类信息中。



### 5 load和initial调用原理

#### 5.1 load

load方法的调用时机：app启动时，runtime加载类和分类的时候

调用顺序：

- 先调用类的load方法，所有类的load方法会按照编译顺序调用，先编译的先调用
- 调用子类的load方法之前，会先调用父类的load方法
- 最后调用分类的load方法，先编译的分类先调用

每个类、分类的load方法只会调用一次，load方法是通过指针直接调用的，并不是通过消息发送机制，因此并不会调用父类的load方法或者被分类的load方法覆盖。



#### 5.2 initialize方法

initialize调用时机：在类第一次接受消息的时候调用。如果这个类没有使用，就不会被调用

调用顺序：

- 调用子类的initialize方法之前，要保证父类的initialize方法先调用
- 如果子类没有实现initialize方法，由于是根据obj_msgsend消息派发，因此会从父类找initialize方法，所以父类的initialize方法可能会被额调用多次（本质是第一次先调用父类本身，然后子类调用的时候跑去父类上查找调用）
- 如果分类实现了initialize方法，则只会使用分类的initialize方法。



#### 5.3 load方法和initialize方法区别

调用方式不同：

- load方法是根据函数地址，直接调用的。
- initialize方法是通过runtime的objc_msgSend来调用的

调用时刻不同：

- load是runtime加载类、分类的时候调用（只会调用一次）
- initialize是类第一次接收到信息的时候调用，每个类只会initialize一次，但是可能存在被子类查找的时候调用多次。

被分类重新的时候调用顺序：

- load：会先调用类的load方法，先编译的类先调用。在调用load方法之前，会先调用父类的load方法。分类中的load方法不会覆盖本类的load方法，先编译的分类先调用load方法
- initialize：先初始化父类，再初始化子类。如果子类没有实现initialize，会调用父类的initialize，所以这种情况父类的initialize会调用多次。如果分类实现的initialize方法，会覆盖类本身的initialize调用。
