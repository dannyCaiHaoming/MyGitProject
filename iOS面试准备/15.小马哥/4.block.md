##### 面试题

- block的原理是怎样的？本质是什么？
- __block的作用是什么？有什么使用注意点？
- block的属性修饰词为什么是copy?使用block有哪些使用注意？
- block在修改NSMutableArray，需不需要添加__block？

### 1. block的本质

从clang命令得到编译后的源码，能看到block底层的实现是由一个`__main_block_impl_0`结构体构成。

而里面又包含`__block_impl_`,`__main_block_desc_0`,`变量`三部分组成。

![](../images/15/block的本质.awebp)

**简要记忆：**

1. block结构的实现，包含他的isa指针，还有函数实现的地址
2. block的描述. 还有存在copy，dispose函数
3. 捕获的变量



#### 1.2 变量捕获

| 类型       | 是否捕抓到block内部 | 访问方式 |
| ---------- | ------------------- | -------- |
| 局部auto   | 是                  | 值       |
| 局部static | 是                  | 指针     |
| 全局static | 否                  | 直接访问 |



#### 1.3 block类型

| block类型      | 环境                                                         |
| -------------- | ------------------------------------------------------------ |
| NSGlobalBlock  | 没有访问auto变量                                             |
| NSStackBlock   | 访问了普通auto变量，没有用`__block`声明的.                   |
| NSMallockBlock | 使用了copy或者被其他地方引用了。此外即使没有被引用但是访问了`__block`变量也会被赋值到堆上。 |



#### 1.4 什么情况下ARC会自动将block进行copy操作？

- block作为函数返回值
- 将block赋值给__strong指针时，也就是block倍强指针引用时
- block作为Cocoa API中方法名含有usingBlock的方法参数时
- block作为GCD API的方法参数时
- block捕获了__block修饰的参数时



### 2 block声明写法

```objc
//MRC:
@property (copy,nonatomic) void (^block) (void);
//ARC
@property (copy,nonatomic) void (^block) (void);
@property (strong,nonatomic) void (^block) (void);
```



### 3 block被拷贝到堆上的内部实现

当block被拷贝到堆上时，会调用`desc`中的copy函数，copy函数内部又会调用`_Block_object_assign`函数

#### 3.1 捕捉auto对象类型的变量。

`Block_object_assign`函数会根据对象类型的变量修饰符：`__strong`,`__weak`,`__unsafe_unretained`产生强引用或者弱引用，类似retain操作，但是如果block位于栈上，不会对捕获的对象产生强引用，不论是捕获\_\_strong还是__weak修饰

#### 3.2 捕获__block值类型修饰的变量

`Block_object_assign`函数会对`__block`值类型变量行程强引用，类似retain。Block拷贝到堆上的同时，也会把`__block`值类型变量同时从栈拷贝到堆上。

#### 3.3 捕获__block对象类型变量

- `Block_object_assign`函数会根据对象的修饰符(`__strong`,`__weak`,`__unsafe_unretained`)做出相应的操作，对__block对象类型变量形成强引用或者弱引用
- 如果block从栈上移除的时候，会调用desc中的dispose函数，dispose函数内部又会调用`Block_object_dispose`函数，`Block_object_dispose`会自动释放auto引用对象，类似release操作。有捕获__block变量的时候，`Block_object_dispose`函数会自动释放引用`__block`变量



### 4 __block的作用

- __block用来解决block内部无法修改auto变量的值的问题
- __block修饰变量：编译器会把修饰的变量重新包装成一个新的对象，`Block_byref_var` 结构体，里面包含了`isa`,`__forwarding`,`变量`以及管理内存的两个函数`copy`和`dispose`。当局部变量的值不需要修改的时候，尽量不要添加`__block`，因为一旦添加了且在block里面使用到，不管需不要改变，`__block`系统会创建对应的结构体，占用不必要的内存空间。
- __block不能修饰全局变量、静态变量(static)
- __forwarding指针指向的是结构体自身的地址值。当使用变量的时候，通过结构体找到`__forwarding`指针，再通过`__forwarding`指针找到相应的栈上或堆上的`block_byref_val`结构上上存储的变量。这样设计的目的是为了方便内存管理，因为block一开始是在栈上，会被拷贝到堆上，捕获的`_block`修饰变量也会一起被拷贝到堆上，在block内部修改捕获变量的时候，为了防止修改的是原来栈上的变量，栈上block中捕获对象的结构体的`__forwarding`指针指向的是堆中的结构体；堆中block中捕获对象的结构体的`__forwarding`指针指向的还是他自己。通过`__forwarding`修改的时候，修改的就是堆上的变量。而我们外部访问的变量实际地址也会变成堆上了。



### 5 解决循环引用

- arc下使用`__weak`或`__unsafe_unretained`修饰对象
- mrc下使用`__block`或者`__unsafe_unretained`

#### 5.1 weak和unsafe_unretained



#### 5.2 __weak后使用\_\_strong

```objc
__weak typeof(self) weakself = self;
person.block = ^ {
    __strong typeof(weakself) strongself = weakself;
    NSLog(@"age is %d", strongself->_age);
}
// block内部使用__strong强引用指向weakself，避免block调用的时候，weakself已经提前释放。
```

