



### 线程同步方案：



### 1. 锁



#### OSSpinLock：自旋锁

- 等待锁的线程会处于忙等的状态，一直占用CPU资源
- 目前不安全，可能存在优先级反转
  - 线程1优先级高，线程2优先级低，线程2先加锁，线程1进来会先尝试获取锁从而忙等了，线程2反而无法有时间工作，线程2无法完成工作。

```objective-c
#import <libkern/OSAtomic.h>

OSSpinLock lock = OS_SPINLOCK_INIT; // C语言属性，要用assign

OSSpinLockLock(&lock);

OSSpinLockUnlock(&lock);
```



### os_unfair_lock: 

- 取代不安全的OSSpinLock，从iOS10开始
- 从底层看，os_unfair_lock锁的线程会处于休眠状态，并非忙等

```objc
#import <os/lock.h>
os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;

os_unfair_lock_lock(&lock);

os_unfair_lock_unlock(&lock);
```





### pthread_mutex:

- mutex叫做互斥锁，等待锁的线程处于休眠状态

```objc
#import <pthread.h>
// 静态初始化方法
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
// 初始化属性
pthread_mutexattr_t attr;
pthread_mutexattr_init(&attr);
pthread_mutexattr_settype(&attr,PTHREAD_MUTEX_DEFAULT);
// 初始化锁
pthread_mutex_init(&_mutex,&attr);
// 销毁属性
pthread_mutexattr_destroy(&attr);
// 销毁
pthread_mutex_destroy(&_mutex);
```



##### 递归锁：允许同一个线程对一把锁进行重复加锁

```
// 递归锁,
pthread_mutexattr_settype(&attr,PTHREAD_MUTEX_RECURSIVE);

例如同一个方法递归调用自己，如果是普通的锁会出现死锁，递归锁是可以重入。
```





##### 条件锁：卡住在条件处。等到条件唤醒条件，才会继续走后面。

```objc
pthread_cond_t cond;
// 初始化条件
pthread_cond_init(&cond,NULL);
// 等待锁的条件
pthread_cond_wait(&cond_&mutex);
// 放开锁
pthread_cond_signal(&cond);
pthread_cond_destroy(&cond);
```





### NSLock、NSRecursiveLock



##### NSCondition：对mutex和cond的封装





### NSConditionLock：对NSCondition的封装，附带条件值





### 2. GCD串行队列，同步执行



### 3. Dispatch_semaphore 信号量控制并发





### 4. @synchronized

是对mutex递归锁的封装





### 锁的效率高到低

- Os_unfair_lock
- OSSpinLock
- Dispatch_semaphore
- pthread_mutex
- Dispatch_queue
- NSLock
- ...
- @synchronized
