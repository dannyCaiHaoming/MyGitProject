

### CPU和GPU

#### CPU功能

- Layout
- Display
- 编解码
- **

#### GPU功能





### 屏幕成像原理

先发出一个(Vsync)垂直同步信号，然后会一行行的发出（Hsync）水平同步信号，更新每一行的数据。



### 卡顿产生的原因



#### CPU卡顿优化

- 尽量用轻量级对象，例如CALayer取代UIView
- 不要频繁调整UIView相关属性，frame，bounds，transform，
- 尽量提前计算好布局，
- Autolayout会比设置frame消耗更多
- 图片的size最好和UIImageView的size一样，就不会过多使用无效资源
- 控制一下线程最大并发数量，线程切换也会耗时
- 大量耗时可以放到子线程
  - 图片处理，解码，绘制
  - 文本处理，尺寸计算



#### GPU卡顿优化

- 尽量减少视图数量和层次？
- 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张图片
- 尽量减少透明视图，混合计算
- 减少离屏渲染



### 离屏渲染

##### OpenGL中，GPU有两个渲染方式

- On-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染

- Off-Screen Rending： 离屏渲染，在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作

##### 离屏渲染消耗性能的原因

- 需要创建新的缓冲区
- 需要多次切换上下文。先从当前渲染的缓冲区切换到另外开辟的缓冲区进行渲染结束后，又要切回到当前缓冲区切回到当前渲染的缓冲区。



##### 哪些操作会造成离屏渲染





### 卡顿检测

通过Runloop检测结束休眠到重新处理source0的之间的时间。





### 耗电优化

##### 耗电来源

- cpu
- 网络
- 定位
- 图像渲染

##### 

##### 耗电优化

- 尽量降低cpu，gpu功耗
- 少用定时器
- 优化IO操作
  - 尽量不要频繁写入小数据，最好批量一次性写入
  - 读写大量重要数据，可以考虑使用GCD的异步操作读写文件。dispatch_io
  - 数据量比较大的时候，使用数据库读写
- 网络优化
  - 减少压缩网络数据，XML->JSON->protobuf
  - 多次请求相同，可以使用缓存
  - 使用断点续传，否则可能多次传输相同的内容
  - 网络不可用，不要执行网络请求
  - 提供合适的超时时间
  - 批量传输，让文件一整个下载，不要分成一个个
- 定位优化
  - 使用一次requestLoaction，不要持续更新定位
  - 尽量降低精度





### APP的启动

##### APP的启动分类：

- 冷启动
- 热启动
- resume，加载进内存，挂在后台，应用被挂起

可以通过设置环境变量`DYLD_PRINT_STATISTICS`监听pre-main耗时



### APP冷启动的阶段概括

- dyld，加载可执行文件，动态库
- runtime，使用runtime加载OC的结构
- main函数



#### dyld

dyld：动态连接器，可以用来装载mach-o文件。（可执行文件，动态库文件）

启动app时，dyld所做的事情

- 装载APP的可执行文件，同时递归加载所有依赖的动态库
- 当dyld把所有可执行文件、动态库装载完毕后，会通知runtime进行下一步处理

#### 

#### runtime

启动app时，runtime会做的事情

- 调用map_images进行可执行文件内容的解析和处理
- 在load_images中调用call_load_method，调用所有Class和Category的+load方法
- 进行各种objc结构的初始化，注册Objc类，初始化类对象等等
- 调用C++静态初始化器

到此为止，可执行文件和动态库中的所有符号Class，Protocol，Selector，IMP都已经按格式成功加载到内存中，被Runtime管理



#### main

总结：

- APP的启动由dyld主导，将可执行文件和动态库进行加载到内存，顺便把所有依赖的动态库加载进来
- 由runtime负责加载成objc定义的结构
- 所有初始化工作结束后，dyld会调用main函数
- 接下来是UIApplicationMain函数，AppDelegate中的didFinishLaunching方法



### APP的启动优化

按照不同阶段

- dyld
  - 减少动态库、合并一些动态库，
  - 减少Objec类，分类的数量，Selector的数量
  - 减少C++的虚函数
  - swift尽量使用struct
- runtime
  - 使用+initialize方法和dispatch_once取代所有c++构造器和objc的+load方法
- main
  - 在不影响用户的体验前提下，将操作延时，不要把所有东西放在didFinishLaunching方法
  - 按需要加载

### 



### 包体优化

安装包主要由可执行文件，资源组成



##### 资源优化

- 采取无损压缩
- 去除没有用到的资源

可执行文件瘦身

- 编译器优化
- 检测没有使用的代码，AppCode

LinkMap



