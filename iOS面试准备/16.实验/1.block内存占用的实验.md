

## 1. 准备

使用两个int型变量，查看两个变量的地址，以及在内存中的分布，来确定iOS中，栈中的变量是怎么“生长”的。

### 1.1 根据代码中`start`变量先于`test `变量，但是内存地址中发现，`start`变量的内存值会小于`test`变量的内存值。查资料也能验证，程序内存块中，栈的地址值分配是`由大到小的`。

![](../images/16/第一步.png)

此外，可以使用view memory功能，根据内存地址值，查看内存中存储的内容。根据`0x7ffeee1ebccc8`地址值，看可以看到`test`变量内存中存储的值是2。 这里高位存储着低位的数据，是因为iOS内存是小端的原因。[大端和小端。](https://www.cnblogs.com/luxiaoxun/archive/2012/09/05/2671697.html)。并且由于int类型占4个字节，因为在堆中往上即往大地址查找4个字节的时候，就能看到`before`变量。

![](../images/16/内存地址内容.png)

### 结论：

根据打印的地址值x，和上一个变量的地址值y，可以根据y-x得到x变量内存中分配的大小，实际占用的问题，还需要考虑`内存对齐`。



## 2. 查看block内存占用

根据第一步的原理，也是用一个int，一个block，内存地址查看。

<img src="../images/16/第二步.jpg" style="zoom: 33%;" />

<img src="../images/16/block内存占用.jpg" style="zoom:50%;" />



### 3. 用block底层代码进行指针内容转换

<img src="../images/16/block内存中存储的内容.jpg" style="zoom:50%;" />

可以看到，篮框中表示的是`impl`指针内存地址中的内容，跟第二个红框中的开头的`8个字节`内容是一样的。应该都是`_block_impl`中`isa`指针的值。查看`_block_desc`中描述block_size的值为40，但是应该是没有算上截获变量的值。截获变量之后应该是44个字节，然后算上内存对齐，应该是会有48个字节。打印上下两个变量的地址值差值可以得到。



### 4. 截获加了__block后的block内存存储了啥

<img src="../images/16/截获__block变量值后的内存.jpg" style="zoom: 50%;" />



加了截获`__block`变量后，无论是block指针的值，还是底层block结构体的内存地址，都是变成了48个字节。最明显的是看到了，底层block结构的最后8个字节，由原来的只是截获变量`02 00 00 00`+内存对齐，变成了`_block_byref_val`结构体的地址值。我怀疑，block指针值的48个字节，后面的32个字节的内容其实和栈中创建的block底层结构体的内容一样，只不过block指针的是指向了堆中的地址。可以用mrc中的block，没有复制到堆之前的地址值看看。





### 5. 多试尝试创建几个查看内存的内容

<img src="../images/16/多创建几个查看内存的内容.jpg" style="zoom: 33%;" />



![](../images/16/多几个block内存中内容.jpeg)



所以能看到后面创建的myblock2,myblock3在内存中的结构，跟底层的结构是一致的。除了第一个block。就只有isa指针的值。



### 6. 终于明白所有内容的值是什么了。



<img src="../images/16/block多次截获同一个变量.jpg" style="zoom:33%;" />



能发现如果使用三次block截获同一个变量值的时候，第一次的时候，会使用完整的`__block_byref_val`24字节空间来存储。并且`__forwarding`指针是堆中变量值的地址。而这时候使用block截获完的变量值的实际地址，会变为堆中实际存储这个变量值的地址。而后面再截获这个变量值的时候，block中只需要使用8个字节的指针指向第一次使用这个变量的栈地址。

<img src="../images/16/截取值在堆中的地址.jpg" style="zoom: 33%;" />

偶然发现红框内的地址值，跟target被截获到堆中的地址值很相近。然后查看一下！

<img src="../images/16/堆中__block_byref_val的值.jpg" style="zoom: 33%;" />

然后就发现了一个跟`__block_byref_val`结构相近的内容，绿框的内容就是`__forwarding`指针指回自身的指针值。24位开始就是被截获变量实际的值。



### 结论：

1. block的内存地址，其实是存储着他指向的block结构体的地址。而内存中又会有内存对齐，因此int和block之间的内存地址值，差值为block指针的8字节，加上int4字节剩余对齐的4字节，等于12字节。
2. block底层的数据结构，跟clang编译后的`__block_impl_0`一致，不算变量的前提下是40个字节，最终的大小要算上截获变量后再内存对齐。



### 7 验证一下

- 堆中的变量，block释放之后，是否内存地址值变回栈中







## 工具：

1. 查看根据内存地址，查看内存中存储的内容

   debug->debug workflow->view memory