## 5 Block

[参考：iOS底层原理总结 ](https://juejin.im/post/5b0181e15188254270643e88#heading-22)

### 5.1 Block介绍

Block是将`函数`及其`执行上下文`封装起来的`对象`

#### 5.1.1 Block描述结构体`__block_impl`

	__block_impl结构
	{
		void *isa;block是对象的标志
		int Flags;
		int Reserved;
		void *FuncPtr;函数指针
	}

#### 5.1.2 什么是Block的调用

即是`函数`的调用

### 5.2 截获变量

#### 5.2.1 变量类型

- 局部变量
 - 基本数据类型
 - 对象类型
- 静态局部变量
- 全局变量
- 静态全局变量

#### 5.2.2

- 对于`基本类型的局部变量`，截获其`值`
- 对于`对象类型的局部变量`，连同所有权`修饰符`一起截获
- 以指针形式截获`局部静态变量`
- 不截获全局变量，静态全局静态变量


### 5.3 __block修饰符

- 一般情况下，对被截获变量进行==赋值==操作则需要添加`__block`修饰符

#### 5.3.1 __block修饰符使用时机

- 局部变量进行修改，==需要==使用`__block`
	- 基本数据类型
	- 对象类型

- ==不需要==使用`__block`
	- 静态局部变量
	- 全局变量
	- 静态全局变量

	
#### 5.3.2 __block修饰的变量变成了`对象`

![block变量变成对象的结构图](https://github.com/dannyCaiHaoming/MyGitProfject/blob/master/iOS%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/images/5/block%E5%8F%98%E9%87%8F%E5%8F%98%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%93%E6%9E%84.png)


#### 5.3.3 MRC和ARC中的区别(原来所有情况都是考虑`block`在堆上，或者`block`跟对象相互持有的情况，网上的资料hhhhhhhhhhh)

在使用了`MRC`跟`ARC`编写一样逻辑的代码，当然内存上有手动管理跟苹果帮我管理的差异。`__block`不一样的原因，是ARC和MRC对局部变量的处理上的不一，ARC默认会`retain`，因此上下文结束后，并不能释放。

- MRC中，`__block`之所以可以接触循环引用，就是因为MRC与ARC的差异，ARC会由苹果帮你管理上下文创建的局部变量何时释放，因此每当你创建一个对象的时候，其实都是相当于`strong`引用，但是MRC则不会，因为MRC是需要你调用`retain`才会帮你持有，因此使用`__block`的时候，相当于在创建一个==block截获变量使用的类(\_\_Block\_byref\_开头)的同时，这个类并没有使用retain方法,还是在栈上==，因此在当`block`调用完上下文之后，这个局部变量会释放，连带着他内部临时创建的存放其它对象的指针的内存都会释放，因此不会再有循环引用的情况。可以理解`MRC`默认是使用`assign`，函数调用上下文结束后，该区域的变量会释放，但是当`block`进行`copy`操作后，复制到==堆==上之后，会增加了引用计数，若这时`block`中持有了一个对象，如果对象是在栈上，那么该变量也会被复制到==堆==上，如果该变量本来就在==堆==上，则会增加引用计数，因此不会被轻易释放。



- ARC中，由于苹果的强大，认为都能帮你管理所有内存的创建和释放，因此创建的变量都可以认为是`strong`，在上下文结束的时候，会由ARC系统去判断这个变量是否可以释放回收。因此在ARC的`__block`，并没有出现像MRC中一样可以解除循环引用，==因为block创建的时候默认已经是在堆上，因此堆中使用到的变量，都会默认复制到堆上==，因此跟`strong`持有的说法是对应上的。因此即使使用了block截获变量使用的类(\_\_Block\_byref\_开头)，==这个截获变量的类是在堆上创建，因此其内部引用的对象都会增加引用计数==，因此在ARC中只能使用`weak`关键字，使得这个截获变量的类是block弱引用的持有的，在block上下文结束的时候，由ARC去处理释放回收。



### 5.4 Block的内存管理

#### 5.4.1 Block分类

![Block分类](https://github.com/dannyCaiHaoming/MyGitProfject/blob/master/iOS%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/images/5/Block%E7%B1%BB%E5%9E%8B)

- 全局Block ---`__NSGlobalBlock__`
	- 没有访问任何外部变量
- 栈Block ---`__NSStackBlock__`
	- 访问了外部变量
- 堆Block ---`__NSMallocBlock__`
	- 使用了`copy`

**PS:** ARC中，==block默认是直接分配到堆中的，如果用`weak`修饰，就不会进行copy操作，仍然会在栈中==。如果作为==参数传递给函数==，那么如果这个==函数中没有使用到copy==，这个block还是会存在于栈中， 当函数结束后，这个block就会被释放，因此不需要使用weak。

**面试题:**  为什么block需要使用copy修饰符：
	由于在函数中使用block，如果block使用了外部变量，但如果此时block使用的是assign，在函数调用结束时，由于block和外部变量均是在栈中，在函数执行期间，可能存在提前释放外部变量的情况，导致引用错误。如果使用了copy，就会将block以及变量复制到堆中，就不会出现内存被回收引起异常。


#### 5.4.2 Block的copy操作

- 栈上的block会复制到堆上
- 堆上的block会增加引用计数
- 全局的block什么也不做

#### 5.4.3 `__forwarding`指针

保证无论`block`是在堆，还是栈上,`__forwarding`指针都能指向正确截获变量的地址

- 如果block在堆上，会指向堆上block的变量
- 如果block在栈上，会指向复制到堆中block的变量，该堆中的`__forwarding`指针遵循上一条



### 5.5 Block的循环引用

#### 5.5.1  MRC下

- `__block`解除循环引用

#### 5.5.2 ARC下

- `__weak`即可在block执行完释放捕获的局部变量
	- `__strong`局部强只有捕获的`__weak`局部变量，可以延后释放时机

----
----
----
----
----
----
----
----
----
----
----
----