#  剑指Offer学习笔记

## 面试题3：数组中重复的数字

### 题目一： 找出数组中重复的数字

在一个长度为n的数组里的所有数字都在`0~n-1`的范围内。数组中某个数字是重复的，但是不知道有几个数字是重复了，也不知道每个数字重复了几次。请找出数组中`任意一个重复的数字`。
    
思路：

- 第一个想法是使用哈希表。但是会使用到额外的存储空间。

题解：

- 将数组重新排序，然后再重头遍历，如果和前一个数字相等则重复
- 由于数字不大于数组的长度，因此数字都基本可以与数组下标对应，因此可以使用比较下标与数字是否相等，不相等则交换位置，若该位置已经有合适的数字，则说明该数字是重复了。


### 题目二： 不修改数组找出重复的数字
在一个长度为`n+1`的数组里的所有的数字都在`1~n`的范围内，所以数组数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。

思路：**二分查找**

- 由于题目说的`n+1`长度的数组中，只有`1~n`的数字，因此如果`1~n`的数字都不重复，只需要长度为`n`的数组。因此是否对半分的时候，`1~n/2`的数字的数组长度只有`n/2`。如果大于`n/2`则说明存在重复的内容，如果小于等于则说明没有。


## 面试题4： 二维数组中的查找

### 题目：
在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序，请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

    1 2 8  9 
    2 4 9  12 
    4 7 10 13 
    6 8 11 15 

题解： **具体问题通过分析具体例子入手，试图寻找普遍规律。**

- 每次取数组最右上角来比较，如果比要查找的数字大，则这一列都舍弃
- 如果右上角的数字比查找的要小，则舍弃这一行。


## 面试题5： 替换空格

### 题目：
请实现一个函数，把字符串的每个空格替换成%20.例如,输入“We are happy.”，则输出"We%20are%20happy."

思路：

- 先分配足够的空间，然后遍历，这个是`开辟了另外一个足够大的空间`

题解：**需要跟面试官确认好需求，是否可以分配另外足够多的的内存**

- 先遍历多少个空格，然后将目前的数组`扩容`
- 准备`p1`,`p2`指针分别指向原来和现在数组的最后
- 从后往前遍历，遇到空格则在`p2`插入%20


## 面试题6： 从头到尾打印链表

### 题目：
输入一个链表的头结点，从尾到头反过来打印出每个节点的值。

思路：**递归** 

- 只要还有下一个链表，就继续找，然后就打印链表内容。

## 面试题7： 重建二叉树

### 题目：
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历结果中都不含重复的数字。例如，输入前序遍历序列[1,2,4,7,3,5,6,8]和中序遍历序列[4,7,2,1,5,3,8,6]

思路： **递归**

- `前序`第一个总是`根节点`
- 根据上一步找到的根节点，能从中序遍历分出左右子树
- 重复上面两个步骤，直到`根节点`的左右子树同时`为空`[注意越界]


## 面试题8： 二叉树的下一个节点

### 题目：
给定一棵二叉树和其中的一个节点，如何找出中序遍历的下一个节点？树中的节点除了有两个分别指向`左、右子节点的指针`，还有一个`指向父节点的指针`。


思路： **将问题结果举例分类好哪几种情况**

- 如果一个节点有右子树，则下一个节点为右子树
- 如果一个节点没有右子树，如果他是父节点的左子树，则下一个节点为父节点
- 如果一个节点没有右子树，且非父节点的左子树。那就沿着父节点一直向上遍历，找到一个是它的父节点的左子树



## 面试题9： 用两个栈实现队列

### 题目：
用两个栈实现一个队列。队列的声明如下，请实现它的两个函数`appendTail`和`deleteHead`，分别完成在队列尾部插入节点和在队列头部删除节点的功能。


思路： **栈：后进先出，队列：先进先出**

- `进->出`:栈A接收所有入队对象，然后出队列的时候，先让栈B接收所有对象，然后再全部吐出去
- `进->出->进->出`：由于需要出列的顺序，因此可以知道在第二次`进`之前，需要将栈A的内容都先转移到栈B
- 因此得到规律：出列的时候，如果栈B无内容，则将栈A内容全部转移


### 题目：用两个队列实现一个栈


## 面试题10： 斐波那契数列

### 题目一：求斐波那契数列的第n项
写一个函数，输入n，求斐波那契数列的第n项。

思路： 只会最垃圾的**递归**

题解： 

- 使用`循环自下而上`，减少重复次数

### 题目二：青蛙跳台阶问题
一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级台阶总共有多少种跳法。

思路：

- 从后往前，逐步分解，每次其实都可以向后退`1步`或`2步`，直到固定`没得退`或者`退回起点`

#### 相关题目：
我们可以用`2x1`的小矩形横着或者竖着去覆盖更大矩形。请问用8个`2x1`的小矩形无覆盖地覆盖一个`2x8`的大矩形，总共有多少总方法。

思路： 

- `f(8)`表示填满`2x8`的大矩形，当竖着在最左侧放入1个`2x1`之后，就相当于需要求填满`2x7`的大矩形的`f(7)`。当横着放入2个`2x1`，因为这也是唯一方法，就成了需要填满`2x6`的大矩形的`f(6)`


## 查找算法（烂熟于心，信手拈来）


### 顺序查找
- 按顺序遍历序列。
- 时间复杂度O(n)

### 二分查找
- 在一个有序序列中，每次折中取值与目标数比较大小，大了就去左边，小了就去右边，重复以上步骤。
- 时间复杂度O(logn)

### 哈希表查找
- 如果已经实现了哈希表，则可以直接通过key，找到value，跟`Dictionary`用法一样（这也叫直接寻址法）

### 哈希函数处理冲突方法

- 拉链法：就是用数组保存`key`，把同一个`key`的`value`用链表连接起来
- 开放线性定值法：当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。这个过程可用下式描述： 
H i ( key ) = ( H ( key )+ d i ) mod m ( i = 1,2,…… ， k ( k ≤ m – 1)) 
其中： H ( key ) 为关键字 key 的直接哈希地址， m 为哈希表的长度， di 为每次再探测时的地址增量。 

### 二叉排序树查找
- 需要熟悉二叉排序树的特性
- 任意节点的左子树不空，左子树上的任意节点都比该节点要小
- 任意节点的右子树不空，右子树上的任意节点都比该节点要大
- 任意节点的左右子树均满足上面两点条件


## 排序算法（烂熟于心，信手拈来）
**从额外空间消耗、平均时间复杂度、最差时间复杂度比较优缺点**

### 冒泡排序
- 从第一位开始，比较相邻两位，如果前者比后者大，则交换
- 一组两个进行第一步工作，直到列表末尾，相当于一次找出一个最大的数
- 从表头开始重复上面的工作，除了最后一位
- 直到指向表头和表位的指针重叠

	- 平均时间复杂度：**O(n<sup>2</sup>)**
	- 最好的情况：**O(n)**
	- 最坏的情况：**O(n<sup>2</sup>)**

#### 选择排序
- 每轮找出最大或者最小的数放在末尾或者头
- 从未排序的元素中继续执行第一步，直到到了末尾或者开头
	- 平均时间复杂度：**O(n<sup>2</sup>)**
	- 最好的情况：**O(n<sup>2</sup>)**
	- 最坏的情况：**O(n<sup>2</sup>)**
	- **不稳定** 举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了

### 插入排序
- 假设将第一个元素作为有序的序列，然后将剩下的元素作为未排序的序列
- 之后每次将无序序列中的元素插入到有序序列中的正确位置
	- 平均时间复杂度：**O(n<sup>2</sup>)**
	- 最好的情况：**O(n<sup>2</sup>)**
	- 最坏的情况：**O(n<sup>2</sup>)**


#### 希尔排序
- 插入排序由于每次都需要用未排序元素跟整个有序序列进行插入操作，因此效率非常低
- 因此将比较分解成每次使用整个序列长度`n`的一半`n/2`去进行插入排序，即可有效省去很多重复的比较
	- 平均时间复杂度：**O(nlogn)**
	- 最好的情况：**O(nlogn)**
	- 最坏的情况：**O(nlogn)**
	- **不稳定**

### 归并排序（分治法）
- 每次将目标序列分成左右两块，然后分别对左右两块继续做分块
- 分到最小块大小为2的时候，对这个最小块进行排序，然后从下而上，对上一步分块做合并排序操作，然后继续从下而上，直到长度恢复原来大小
	- 平均时间复杂度：**O(nlogn)**
	- 最好的情况：**O(nlogn)**
	- 最坏的情况：**O(nlogn)**


### 快速排序（分治法）
- 从数列中跳出一个元素，开头或结尾都可以
- 然后依据这个元素，将未排序序列分成小于这个标记在左边，大于这个标记在右边
- 将左右序列以上面两步重复执行，直到左右分布序列长度为1
- 核心是怎么写出`Partition`这个函数，怎么把一个无序序列用一个随机数分成左边小，右边大。
	- 选一个基准数，先将原先序列剔除这个基准数，其实最好就是把这个基准数跟末尾的元素替换
	- 将比这个基准数小的元素都替换到序列的前头，然后继续下下一个序号
	- 当整个无序序列排完之后，再将记录下的序号跟末尾替换，就完成了`Partition`

#### 堆排序
- 将无序序列构造成大顶堆
- 

#### 桶排序


## 面试题11：旋转数组的最小数字
### 题目：
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入的一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组[3,4,5,1,2]为[1,2,3,4,5]的一个旋转，该数组的最小值为1.

思路：**二分查找**
- 由于是将排序好的数组切割前面一段放到后面，因此可以看成是A+B两个排序好的数组，并且A的所有元素都比B大
- 当从中间选择一个元素的时候，如果比A的头大，则证明处于A中，因此需要继续往B方向找，
- 如果比A的头小，则需要往A的方向找

题解：**注意特殊情况**
- 如果当A的头，B的尾，跟中间元素相等时候


## 面试题12：矩阵中的路径（回溯法，递归）
### 题目：
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个开始，每一步可以在矩阵中向左、右、上、下移动一个。如果一条路径经过了矩阵的某一个，那么该路径不能再次进入该格子。

题解： 

- 递归内容就是寻找矩阵中某个元素的，上、下、左、右元素是否匹配字符串的下一个字符，递归的结果就是`上|下|左|右`的结果
- 第一个字符由于题干说可以由题目任意位置开始，因此需要遍历整个矩阵作为递归入口
- 由于不能重复走，因此还需要增加一个矩阵用于计算该位置是否走过了，而这个表示位置占用的标志位在进入这个字符的递归计算时要先置真，呆到这个字符的递归失败了，再需要将这个标志位置假



## 面试题13：机器人的运动范围
### 题目：
地上有一个m行n列的方格。一个机器人从坐标(0,0)的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。

































