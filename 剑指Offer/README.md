#  剑指Offer学习笔记

## 面试题3： 数组中重复的数字

### 题目一： 找出数组中重复的数字

在一个长度为n的数组里的所有数字都在`0~n-1`的范围内。数组中某个数字是重复的，但是不知道有几个数字是重复了，也不知道每个数字重复了几次。请找出数组中`任意一个重复的数字`。
    
思路：

- 第一个想法是使用哈希表。但是会使用到额外的存储空间。

### 题解：

- 将数组重新排序，然后再重头遍历，如果和前一个数字相等则重复
- 由于数字不大于数组的长度，因此数字都基本可以与数组下标对应，因此可以使用比较下标与数字是否相等，不相等则交换位置，若该位置已经有合适的数字，则说明该数字是重复了。


### 题目二： 不修改数组找出重复的数字
在一个长度为`n+1`的数组里的所有的数字都在`1~n`的范围内，所以数组数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。

思路：**二分查找**

- 由于题目说的`n+1`长度的数组中，只有`1~n`的数字，因此如果`1~n`的数字都不重复，只需要长度为`n`的数组。因此是否对半分的时候，`1~n/2`的数字的数组长度只有`n/2`。如果大于`n/2`则说明存在重复的内容，如果小于等于则说明没有。


## 面试题4： 二维数组中的查找

### 题目：
在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序，请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

    1 2 8  9 
    2 4 9  12 
    4 7 10 13 
    6 8 11 15 

### 题解： **具体问题通过分析具体例子入手，试图寻找普遍规律。**

- 每次取数组最右上角来比较，如果比要查找的数字大，则这一列都舍弃
- 如果右上角的数字比查找的要小，则舍弃这一行。


## 面试题5： 替换空格

### 题目：
请实现一个函数，把字符串的每个空格替换成%20.例如,输入“We are happy.”，则输出"We%20are%20happy."

思路：

- 先分配足够的空间，然后遍历，这个是`开辟了另外一个足够大的空间`

### 题解：**需要跟面试官确认好需求，是否可以分配另外足够多的的内存**

- 先遍历多少个空格，然后将目前的数组`扩容`
- 准备`p1`,`p2`指针分别指向原来和现在数组的最后
- 从后往前遍历，遇到空格则在`p2`插入%20


## 面试题6： 从头到尾打印链表

### 题目：
输入一个链表的头结点，从尾到头反过来打印出每个节点的值。

思路：**递归** 

- 只要还有下一个链表，就继续找，然后就打印链表内容。

## 面试题7： 重建二叉树

### 题目：
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历结果中都不含重复的数字。例如，输入前序遍历序列[1,2,4,7,3,5,6,8]和中序遍历序列[4,7,2,1,5,3,8,6]

思路： **递归**

- `前序`第一个总是`根节点`
- 根据上一步找到的根节点，能从中序遍历分出左右子树
- 重复上面两个步骤，直到`根节点`的左右子树同时`为空`[注意越界]


## 面试题8： 二叉树的下一个节点

### 题目：
给定一棵二叉树和其中的一个节点，如何找出中序遍历的下一个节点？树中的节点除了有两个分别指向`左、右子节点的指针`，还有一个`指向父节点的指针`。


思路： **将问题结果举例分类好哪几种情况**

- 如果一个节点有右子树，则下一个节点为右子树
- 如果一个节点没有右子树，如果他是父节点的左子树，则下一个节点为父节点
- 如果一个节点没有右子树，且非父节点的左子树。那就沿着父节点一直向上遍历，找到一个是它的父节点的左子树



## 面试题9： 用两个栈实现队列

### 题目：
用两个栈实现一个队列。队列的声明如下，请实现它的两个函数`appendTail`和`deleteHead`，分别完成在队列尾部插入节点和在队列头部删除节点的功能。


思路： **栈：后进先出，队列：先进先出**

- `进->出`:栈A接收所有入队对象，然后出队列的时候，先让栈B接收所有对象，然后再全部吐出去
- `进->出->进->出`：由于需要出列的顺序，因此可以知道在第二次`进`之前，需要将栈A的内容都先转移到栈B
- 因此得到规律：出列的时候，如果栈B无内容，则将栈A内容全部转移


### 题目：用两个队列实现一个栈


## 面试题10： 斐波那契数列

### 题目一：求斐波那契数列的第n项
写一个函数，输入n，求斐波那契数列的第n项。

思路： 只会最垃圾的**递归**

### 题解： 

- 使用`循环自下而上`，减少重复次数

### 题目二：青蛙跳台阶问题
一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级台阶总共有多少种跳法。

思路：

- 从后往前，逐步分解，每次其实都可以向后退`1步`或`2步`，直到固定`没得退`或者`退回起点`

#### 相关题目：
我们可以用`2x1`的小矩形横着或者竖着去覆盖更大矩形。请问用8个`2x1`的小矩形无覆盖地覆盖一个`2x8`的大矩形，总共有多少总方法。

思路： 

- `f(8)`表示填满`2x8`的大矩形，当竖着在最左侧放入1个`2x1`之后，就相当于需要求填满`2x7`的大矩形的`f(7)`。当横着放入2个`2x1`，因为这也是唯一方法，就成了需要填满`2x6`的大矩形的`f(6)`


## 查找算法（烂熟于心，信手拈来）


### 顺序查找
- 按顺序遍历序列。
- 时间复杂度O(n)

### 二分查找
- 在一个有序序列中，每次折中取值与目标数比较大小，大了就去左边，小了就去右边，重复以上步骤。
- 时间复杂度O(logn)

### 哈希表查找
- 如果已经实现了哈希表，则可以直接通过key，找到value，跟`Dictionary`用法一样（这也叫直接寻址法）

### 哈希函数处理冲突方法

- 拉链法：就是用数组保存`key`，把同一个`key`的`value`用链表连接起来
- 开放线性定值法：当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。这个过程可用下式描述： 
H i ( key ) = ( H ( key )+ d i ) mod m ( i = 1,2,…… ， k ( k ≤ m – 1)) 
其中： H ( key ) 为关键字 key 的直接哈希地址， m 为哈希表的长度， di 为每次再探测时的地址增量。 

### 二叉排序树查找
- 需要熟悉二叉排序树的特性
- 任意节点的左子树不空，左子树上的任意节点都比该节点要小
- 任意节点的右子树不空，右子树上的任意节点都比该节点要大
- 任意节点的左右子树均满足上面两点条件


## 排序算法（烂熟于心，信手拈来）
**从额外空间消耗、平均时间复杂度、最差时间复杂度比较优缺点**

### 冒泡排序
- 从第一位开始，比较相邻两位，如果前者比后者大，则交换
- 一组两个进行第一步工作，直到列表末尾，相当于一次找出一个最大的数
- 从表头开始重复上面的工作，除了最后一位
- 直到指向表头和表位的指针重叠

	- 平均时间复杂度：**O(n<sup>2</sup>)**
	- 最好的情况：**O(n)**
	- 最坏的情况：**O(n<sup>2</sup>)**

#### 选择排序
- 每轮找出最大或者最小的数放在末尾或者头
- 从未排序的元素中继续执行第一步，直到到了末尾或者开头
	- 平均时间复杂度：**O(n<sup>2</sup>)**
	- 最好的情况：**O(n<sup>2</sup>)**
	- 最坏的情况：**O(n<sup>2</sup>)**
	- **不稳定** 举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了

### 插入排序
- 假设将第一个元素作为有序的序列，然后将剩下的元素作为未排序的序列
- 之后每次将无序序列中的元素插入到有序序列中的正确位置
	- 平均时间复杂度：**O(n<sup>2</sup>)**
	- 最好的情况：**O(n<sup>2</sup>)**
	- 最坏的情况：**O(n<sup>2</sup>)**


#### 希尔排序
- 插入排序由于每次都需要用未排序元素跟整个有序序列进行插入操作，因此效率非常低
- 因此将比较分解成每次使用整个序列长度`n`的一半`n/2`去进行插入排序，即可有效省去很多重复的比较
	- 平均时间复杂度：**O(nlogn)**
	- 最好的情况：**O(nlogn)**
	- 最坏的情况：**O(nlogn)**
	- **不稳定**

### 归并排序（分治法）
- 每次将目标序列分成左右两块，然后分别对左右两块继续做分块
- 分到最小块大小为2的时候，对这个最小块进行排序，然后从下而上，对上一步分块做合并排序操作，然后继续从下而上，直到长度恢复原来大小
	- 平均时间复杂度：**O(nlogn)**
	- 最好的情况：**O(nlogn)**
	- 最坏的情况：**O(nlogn)**


### 快速排序（分治法）
- 从数列中跳出一个元素，开头或结尾都可以
- 然后依据这个元素，将未排序序列分成小于这个标记在左边，大于这个标记在右边
- 将左右序列以上面两步重复执行，直到左右分布序列长度为1
- 核心是怎么写出`Partition`这个函数，怎么把一个无序序列用一个随机数分成左边小，右边大。
- 选一个基准数，先将原先序列剔除这个基准数，其实最好就是把这个基准数跟末尾的元素替换
- 将比这个基准数小的元素都替换到序列的前头，然后继续下下一个序号
- 当整个无序序列排完之后，再将记录下的序号跟末尾替换，就完成了`Partition`
	- 平均时间复杂度：**O(nlogn)**
	- 最好的情况：**O(nlogn)**
	- 最坏的情况：**O(n<sup>2</sup>)**
	- **不稳定**

#### 堆排序
- **完全二叉树的特性（可以使用数组存储）**
	- 下标为`i`的元素，下标为`2i`的元素是该元素的`左子节点`，下标为`2i+1`的元素是该元素的`右子节点`
- 根据以上`完全二叉树`特性，使用`(len/2)-1`找到最后一个叶子的父节点，从这个父节点开始往上浮大的元素
- 在这些父节点`递归`查找父子节点中哪个元素最大，然后交换,这里有个要点，就是交换之后的元素，需要重新`递归`查找交换后子节点的最大元素，判断下沉的元素也需要在该子树上是最大的。
- 堆排序就是用构建大顶堆的`递归函数`，每次取出最大一位放到最后一位，然后重新构建一个大顶堆
#### 桶排序


## 面试题11： 旋转数组的最小数字
### 题目：
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入的一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组[3,4,5,1,2]为[1,2,3,4,5]的一个旋转，该数组的最小值为1.

思路：**二分查找**最难的还是找出判定条件
- 由于是将排序好的数组切割前面一段放到后面，因此可以看成是A+B两个排序好的数组，并且A的所有元素都比B大
- 当从中间选择一个元素的时候，如果比A的头大，则证明处于A中，因此需要继续往B方向找，
- 如果比A的头小，则需要往A的方向找

### 题解：**注意特殊情况**
- 如果当A的头，B的尾，跟中间元素相等时候


## 面试题12： 矩阵中的路径（回溯法，递归）
### 题目：
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个开始，每一步可以在矩阵中向左、右、上、下移动一个。如果一条路径经过了矩阵的某一个，那么该路径不能再次进入该格子。

### 题解： 

- 递归内容就是寻找矩阵中某个元素的，上、下、左、右元素是否匹配字符串的下一个字符，递归的结果就是`上|下|左|右`的结果
- 第一个字符由于题干说可以由题目任意位置开始，因此需要遍历整个矩阵作为递归入口
- 由于不能重复走，因此还需要增加一个矩阵用于计算该位置是否走过了，而这个表示位置占用的标志位在进入这个字符的递归计算时要先置真，呆到这个字符的递归失败了，再需要将这个标志位置假



## 面试题13： 机器人的运动范围
### 题目：
地上有一个m行n列的方格。一个机器人从坐标(0,0)的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。请问机器人能够到达多少个格子？

### 题解：

- 题目要计算最多格子数，所以隐含不能重复到达的条件，但是这里跟**面试题12**不一样，到达过的就算下次有机会进来也不用判断，因为这个位置在这次已经计算了能继续增加多少格子
- 跟**面试题12**一样，**递归**移动，判断的条件由字符串相等变成数位之和不能大于k，并且要在**rows**和**columns**内

## 面试题14： 剪绳子
###题目：
给你一根长度为n的绳子，请把绳子剪成m段(m,n都是整数，并且都大于1)，每段绳子的长度记为k[0],k[1]...k[m]。请问k[0]xk[1]x....k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2,3,3的两段，此时得到的最大乘积是18.

### 动态规划(自下而上，逐个逐个求最优)



### 贪婪算法


## 面试题15： 二进制中1的个数
### 题目：
请实现一个函数，输入一个`整数`，输出该数的二进制表示中1的个数，

思路：

- 将这个整数按照十进制转二进制的方式，每次除二并且看是否能整除二

### 题解：
看完题解之后发现自己真的太蠢了

- **二进制负数表示用`补码方式`，将这个数的正数二进制表示按位取反，然后再+1**
- **位运算比除法效率高**	
 - **右移代替除以2**
 - **与运算代替求余**
 
#### 基本解法

- 基本思路就是将数跟1做与操作
- 而做完与操作之后，得到1还是0，这位就废弃了，就可以看左移还是右移
- 如果是右移那么就可能存在问题，因为题目说的整数，可以是正数，可以是负数，如果是负数的话，首位就需要是1来表示负数，如果右移的话，位移后最高位还是会设为1，因此将没有条件停止右移判断。
- 左移的话，只能将进行与操作数`flag`进行左移

#### 利用规律

- **二进制数减一之后与原来的数做&操作，将会消除最后一位的1**


## 面试题16:  数值的整数次方
### 题目：
实现函数`Power(double base,int exponent)`，求base的exponenet次方。

### 题解：

- 注意浮点数跟0的比较
- 注意指数的区间，`小于0`，`等于0`，`大于0`

#### 基本解法

- 将`exponent`判断是否为0
- 将`exponent`取绝对值后，循环求得`base`的`exponent`次幂
- 如果`exponent`是负数，则取个倒数


#### 利用斐波那契数列的公式

![斐波那契数列公式](https://github.com/dannyCaiHaoming/MyGitProfject/blob/master/%E5%89%91%E6%8C%87Offer/images/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%85%AC%E5%BC%8F.png)

- 就是将`exponent`递归分解成一半，直到分解成1，或者0
- **ps** 
 - **除2运算可以用右移运算符**
 - **用位与运算符代替%2的求余运算**

 
## 面试题17： 打印从1到最大的n位数
### 题目
输入数字n，按照顺序打印出从1到最大的n位是十进制数。

思路：

- 有多少位就构建多长的数组，每次从最后一位加一，然后从后往前判断是否需要进一位
- 然后还要判断是否达到最大值
- 然后每次加一后都要遍历找个数组进行打印
 
### 题解:

#### 基本解法
- 用字符串表示数组，这样打印的时候就能省去遍历的时间
- 而且也能直接进行对字符串转数字然后做加一操作
- 实现一个新的打印方法，遇到第一个非“\0”的内容开始才打印，直到末尾

#### 换种思路（递归）
- 第`n`位数从0-9每一次排列的时候，就是每一次第`n-1`从0-9排列出来，因此可以递归分解成前面的数从0-9排列，结束的条件就是n为0或者说是最后一位的时候



## 面试题18： 删除链表的节点

### 题目一：在O(1)时间内删除链表节点
给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。

思路：

- 往常的想法都是找到下一个要删除的节点，然后把当前节点的`next`指向删除节点的下一个
- **现在换个思路**，将要删除的节点的内容替换成下一个节点内容，然后把删除节点的`next`指向下一个节点的`next`



### 题目二：删除链表中重复的节点
在一个排序的链表中，如何删除重复的节点？例如:（a）删除后如(b)

（a）1->2->3->3->4->4->5

（b）1->2->5

思路：

- 用一个标志位，标志最新一个没有重复的节点值
- 循环遍历链表，将每个链表跟当前标志值比较，不相等的时候才能作为当前链表的`next`值


### 题解：（链表题目）

- (1)需要用原指针表示完整链表入口，因此原来的`pHead`指针指向不能改变
- (2)因此需要定义一个`pNode`指向`pHead`用于遍历链表
- (3)这题还需要一个`pPreNode`用于指向最后一个没有重复的节点
- (4)链表题目注意边界条件测试











-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------
-------------