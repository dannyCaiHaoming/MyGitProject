### 简介





### 1. 在Exploit-DB中搜索Web服务器漏洞

##### 工作原理

`searchsploit`命令是安装在 Kali 中的 Exploit-DB 本地副本的接口。它用于在利用的标题和描述中搜索字符串，并显示结果。

利用存在于`/usr/share/exploitdb/platforms`目录中。`searchsploit`所展示的利用目录是它的相对路径，这就是我们在复制文件的时候使用完整路径的原因。利用文件以利用编号命名，在它们被提交到Exploit-DB 时分配。

编译步骤和在源代码中的推荐有些不同，因为 OpenSSL 库在基于 Debian 的发行版中，由于它们从源代码中构建的方式而缺少一些功能。





### 2. 利用Heartbleed漏洞



这里由于编辑`Exploit-db`中`heartbleed`失败。因此这里找了替代方案使用了`msfconsole`去实践。



##### Heartbleed漏洞产生

基于ssl/tls的通信，由于需要保活的需求，会有个`心跳`机制，客户端会定时往服务器上发送请求，而这个请求一般会带上请求的内容的长度。于是，在恶意攻击中，客户端在请求内容同时对长度进行一个恶意增大，例如一个bird字符，要求500字母长度的返回。这时候服务器就会根据请求消息长度在内存缓冲区中存储更多内容，并且将这些消息返回。



##### 操作步骤

1. 使用`bwapp`靶机
2. 使用msfconsole

```shell
use auxiliary/scanner/ssl/open_ssl_heartbleed
set RHOST 目标ip
set RPORT 端口
set verbose true 
```

使用metasploit的open_ssl_heartbleed模块。一开始在靶机进行账号登录，并不能获取到内存中的敏感信息。需要用其他机器的浏览器访问靶机，进行账号登录，就能在攻击后，返回内存中的账号密码等信息。







### 3. 使用BeEF利用XSS

暗月提供的kali系统无法安装Beef。



BeeEF，即浏览器利用框架，是个专注于客户端攻击向量的框架，特别是 Web 浏览器的攻击。

这个秘籍中，我们会利用 XSS 漏洞并使用 BeEF 来控制客户端浏览器。



##### 工作原理

这个秘籍中，我们使用了`script`标签的`src`属性来调用外部 JS 文件，这里是 BeEF的钩子。

`hook.js`文件与服务器通信，执行命令并返回响应，使攻击者能够看到它们。它在客户端的浏览器中不打印任何东西，所以受害者通常不会知道他的浏览器正在被攻击。

在让受害者执行我们的`hook`脚本之后，我们使用持久化模块 Man In The Browser 使浏览器在每次用户点击链接时，向相同域发送 AJAX 请求，所以这个请求维持了钩子，也加载了新的页面。

我么也会看到，BeEF 的日志记录了用户在页面上执行的每个步骤，我们能够从中获得用户名和密码信息。也可以用来获得远程的会话 Cookie，这可以让攻击者劫持受害者的会话。







### 4. 利用SQL盲注





##### 工作原理

利用 SQL 盲注比起基于错误的注入花费更多精力和时间。在这个秘籍中我们看到了如何获取连接到数据库的用户名，而在第六章的 SQL 注入利用汇总，我们使用了一条命令来获取它。

我们可以使用字典来查看当前用户是否在名称列表中，但是如果名称不在列表中，会花费更多时间。

我们最开始识别了漏洞，所显示的信息告诉我们我们的请求是真是假。

一旦我们知道存在注入，并且正面的响应是什么样子，我们开始询问当前用户的长度，询问数据库，`1`是否是当前用户名的长度，是不是`2`，以此类推，知道我们发现了长度。知道何时停止用户名长度的搜索非常重要。

在找到长度之后，我们使用相同的技巧来发现首字母，`LIKE 'b%'`语句告诉 SQL 解释器是否首字母是`b`，剩下的并不重要，它可以是任何东西（`%`是用于多数 SQL 实现的通配符）。这里，我们看到了首字母是`S`。使用相同的技巧，我们就能发现第二个字符，并得到整个名称。



##### 操作步骤

1. dvwa靶场的WebGoat项目，使用`webgoat`作为用户名和密码登录
2. 选择`Injection Flaws | Blind Numeric SQL Injection`
3. 然后就是用Brup Suite进行盲注



### 5. 使用 SQLMap 获得数据库信息



##### 操作步骤

1. 使用`bee-box`靶机，登录好选择SQL注入漏洞(POST/Search)
2. 使用Burp Suite抓取search的请求
3. 使用sqlmap进行攻击

```shell
// 查询判断是否当前用户是DBA
sqlmap -u ip地址 --cookie=cookie值 --data post请求数据拼接  -p 尝试注入的参数 --is-dba
// 获取登录sql的用户和密码
sqlmap -u ip地址 --cookie=cookie值 --data post请求数据拼接  -p 尝试注入的参数 --is-dba --user --password
// 获取shell，直接操作SQL数据库
sqlmap -u ip地址 --cookie=cookie值 --data post请求数据拼接  -p 尝试注入的参数 -sql-shell
```



##### 工作原理

在这个对 SQLMap 的调动中，我们使用了`--cookie`参数来发送会话 Cookie 因为应用需要身份验证来访问`sqli_6.php`页面。`--data`参数包含发送到服务器的 POST 数据，`-p`告诉 SQLMap 仅仅注入`title`参数，`--is-dba`询问数据库当前用户是否拥有管理员权限。

DBA 允许我们向数据库询问其他用户的信息，SQLMap 通过`--users`和`--passwords`使我们的操作变得更加容易。这些参数询问用户名和密码，因为所有 DBMS 将用户的密码加密存储，我们获得的只能是哈希。所以我们仍然要使用密码破解器来破解它们。如果你在 SQLMap 询问你执行字典攻击的时候回答`Yes`，你可能就知道了至少一个用户的密码。

我们也使用了`--sql-shell`选项来从我们向数据库发送的 SQL 查询中获得 shell。这并不是真的 shell，当然，SQLMap 通过 SQL 注入发送我们写的命令，并返回这些查询的结果。





### 6. 执行 CSRF 攻击

CSRF 攻击强迫身份验证后的用户在 Web 应用中执行需要身份验证的，非预期的行为。这可以通过用户所浏览的外部站点触发该行为来实现。

这个秘籍中，我们会获取应用中的信息，来观察攻击站点是否能够发送有效的请求给漏洞服务器。之后，我们会创建页面来模拟正常请求并诱使用户在身份验证后访问这个页面。恶意页面之后会发送请求给漏洞服务器，如果应用在相同浏览器中打开，它会执行操作，好像用户发送了它们。







### 7. 使用 Shellsock 执行命令

Shellshock（也叫作Bashdoor）是个在 2014 年九月发现在 Bash shell 中的bug，允许命令通过储存在环境变量中的函数来执行。

Shellshock 和我们渗透测试者有关系，因为开发者有时候允许我们在 PHP 或 CGI 脚本中调用系统命令 -- 这些脚本可以利用系统环境变量。

这个秘籍中，我们会在 Bee-box 漏洞虚拟机中利用 Shellshock 漏洞来获得服务器的命令执行权



##### 工作原理

在第一步中，我们发现了 shell 脚本的调用。因为它可以被 shell 解释器运行，它可能是漏洞版本的 bash。为了验证，我们执行了下列测试：

```sh
() { :;}; echo "Vulnerable:"
```

第一个部分`() { :;};`是个空函数，因为 bash 可以将函数储存为环境变量，这个是漏洞的核心。在函数结束之后，解析器会继续解释（并执行）命令，这允许我们执行第二个部分`echo "Vulnerable:`，这是简单返回输入的命令。

Web 服务器中存在漏洞，因为 CGI 事先将请求的所有部分映射为环境变量，所以这个攻击通过`User-Agent`或者`Accept-Language`也能工作。

一旦我们知道了服务器存在漏洞，我们键入测试命令`ifconfig`并建立反向 shell`。

反向 shell 是一种远程 shell，它的特点是由受害者主机初始化，攻击者监听连接，而不是服务器在绑定连接中等待客户端的连接。





### 8. 使用 John the Ripper 和字典来破解密码哈希





### 9. 使用 oclHashcat/cudaHashcat 爆破密码哈希

最近，显卡的发展取得了巨大突破，这种芯片中含有成百上千个处理器，它们都并行工作。这里，当应用在密码破解上是，这意味着，如果单个处理每秒可以计算一万个哈希，一个带有上千内核的 GPU 就能够计算一千万个。这可以将破解时间降至一千分之一。

现在我们使用 Hashcat 的 GPU 版本来爆破密码。如果你在 N 卡的电脑上安装的 Kali，你需要 cudeHashcat。如果它安装在 A 卡的电脑上，则需要 oclHashcat。如果你在虚拟机上安装 kali，GPU 破解可能不工作，但是你始终可以在你的主机上安装它，Windows 和 Linux 上都有它的版本。

这个秘籍中，我们会使用 oclHashcat，它和 cudaHashcat 的命令没有区别，虽然 A 卡对于密码破解更加高效。





##### 工作原理

在这个秘籍中，我们用于执行`oclHahcat`的参数定义了要使用的哈希算法：`-m 0`告诉程序使用 MD5 来计算所生成单词的哈希，以及攻击类型，`-a 3`的意思是我们打算使用纯爆破攻击，并尝试所有可能的字符组合，直到发现了密码。最后，我们在第一种情况中添加了我们打算破解的哈希，第二种情况中我们添加了包含哈希集合的文件。

oclHahcat 也可以使用字典文件来执行混合攻击（爆破加上字典）来定义要测试哪个字符集，并将结果保存到指定文件中（`/usr/share/oclhashcat/oclHashcat.pot`）。他也可以对单词应用规则，并使用统计模型（马尔科夫链）来增加破解效率。使用`--help`命令来查看所有选项，像这样：

