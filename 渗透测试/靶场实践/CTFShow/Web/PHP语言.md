#### 代码审核





#### 1. 序列化相关

##### 1. 反序列化

将php对象，转换成字符串，这个过程就是`序列化`。

`反序列化`，就是将字符串，恢复为php对象。

`反序列化漏洞`，即构造特殊字符串，在源码执行过程中，导致恢复对象的时候，被攻击者使用非流程或者使用了非正常的数据达到获取flag的目的。

魔术方法：

```php
__construct() # 当对象构造时被调用
__destruct() #当对象被析构时被调用
__toString() # 当一个对象被当做字符串时被调用,如echo，和字符串拼接
__wakeup()  # 当使用unserialize时触发
__sleep() # 当使用serialize时触发
__call() # 当对象调用存在的方法时触发
__calStatic # 调用上下文不存在的静态方法时触发
__get() # 调用不可访问的属性时触发
__set() # 写入不可能访问的属性时触发
__isset() # 不可访问的属性上调用isset时触发
__unset() # 不可访问的属性上调用unset时触发
__invoke() # 尝试将对象当做函数调用时触发
```



##### 2. 序列化引用

当flag的值无法直接输出，则可以构造能够输出的值，进行指针指向flag的值，这样flag和能够输出的值，都会是一样。

关键是选好序列化对象的，看清楚`key`，才能准确找出数量排序。



#### 3. 绕过

当遇到一些在`__wakeup()`中执行特殊逻辑的时候，构造特殊的字符串进行反序列化。

**将表示属性个数的值改成大于真实属性的值，就会绕过__wakeup()函数执行**



#### 4. fast_destruct

序列化成php对象之后，就进入对象内存管理的逻辑，像iOS的对象，如果有别的指针引用，那么这个对象的引用计数就会加一，执行完得等到引用对象释放了持有，那这个对象才能够被释放。因此会有一些相似的总结：

```markdown
1、PHP中，如果单独执行unserialize函数进行常规的反序列化，那么被反序列化后的整个对象的生命周期就仅限于这个函数执行的生命周期，当这个函数执行完毕，这个类就没了，在有析构函数的情况下就会执行它。
2、PHP中，如果用一个变量接住反序列化函数的返回值，那么被反序列化的对象其生命周期就会变长，由于它一直都存在于这个变量当中，那么在PHP脚本走完流程之后，这个对象才会被销毁，在有析构函数的情况下就会将其执行。
```

但是，如果要解除这种引用，会有一种方式，就是使用上面的`绕过方式`。当序列化过程出错，就是序列化字符串中的对象个数大于实际的时候，我理解为错误的序列化过程，就会导致这个对象无法被另外的指针持有，提前进入析构的过程。

基于此，可以用来绕过一些，在析构函数中执行的特殊逻辑，但是这个析构后的对象，暂时被其他指针持有，导致正常流程不会执行。



#### 5. 反序列化逃逸

反序列化逃逸，用于修改类中某个变量的值。具体实现，就是通过提前对序列化字符串，提前使用`"};`闭合，而后面原来值的序列化字符串，由于前面的已经构造好了，因此后面的就不会再进行解析。

分过滤后字符变多和变少的情况，网上随便找的，举例子的不清不楚，搞不清楚先后顺序条件。

简单来说，就是出现会增加或者减少序列化字符串的replace方法，导致我们输入的序列化串，达到提前或者延后闭合。

- 变短的

```php
# 原先是  19个x
a:2:{i:0;s:7:"xxxxxxxxxxxxxxxxxxx";i:1;s:13:"where is flag";}
# 被执行replace后，替换18个x剩下1个x，导致后面的内容推前了。
#  `";i:1;s:4:"flag";}`  刚好长度是18，被替换后，推导原先18个x的
a:2:{i:0;s:7:"x";i:1;s:4:"flag";}";i:1;s:13:"where is flag";}
```

- 变长的

```php
# 原先是1个x
a:2{i:0;s:1:"x";i:2;s:13:"you are wrong";}
# 被执行replace后，增加了29个x，直接把后面的顶掉，但是多出来的会被逃逸忽略了
# 但是仍然需要构造一个完成的可以序列化出来的字符串，简单匹配一下
# 同样，后面原来的序列化串就不会被解析了。
a:2{i:0;s:1:"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";i:2;s:5:"right";}";i:2;s:13:"you are wrong";}
```







##### 888.php中执行命令的方法

1. system 

执行外部程序（命令行），并且显示输出。

2. shell_exec

通过shell环境执行命令

3. exec

执行一个外部程序，返回命令执行结果的最后一行

4. passthru

执行外部程序，并且显示原始输出。

5. echo('ls') , echo ls

6. `<?=`  等价于 `<?php echo`





##### 999. md5绕过



###### 1. 不同的字符串和整形，他们的md5值是可以判断

```php
if(isset($v1) && isset($v2)){
	if(!ctype_alpha($v1)){
      die("v1 error");
  }
  if(!is_numeric($v2)){
    die("v2 error");
  }
  if(md5($v1)==md5($v2)){
    echo $flag;
  }
}
#  我们可以采用科学计数法进行绕过，但一个需要全为数字，一个需要全为字母
# 数字
# 240610708  0e462097431906509019562988736854
# 字母
# QNKCDZO    0e830400451993494058024219903391
```

具体要怎么算？







#### 题目：



###### 1. ctf.show_web11

直接给了源码，就是判断`$_Session['password']=$GET['passwod']`，那就把发送的和session中的都删除掉。



###### 2. ctf.show_web11

需要用到php中特殊的输出字符串方法，筛选当前目录文件，还有打印指定文件。



###### 3. ctf.show_红包题

这道题和大部分人一样，cmd之后，看见密密麻麻的筛选条件，还有爆破目录后无果。

看答案，大致是3个要点：

- php上传文件，就是表单上传必定会有`Content_type:multipart/form-data;`的表头，而php又会将上传文件临时保存起来，保存的目录会在`.php.ini`,linux会默认在`/tmp`下。此外文件的命名格式都有固定`为phpXXXX.tmp（Windows中）、php**.tmp（Linux中）`。
- `即使绝望，还得细心`。观察筛选条件中，上帝往往给你开个小口。剩下`.<>?=/`还有`p`没有防范。
- shell命令中，使用`.`代替`source`命令，执行文件中的命令
- shell命令中，`<?=`  等价于 `<?php echo`
- shell命令中，`+`在url中表示空格，利用`?`通配符去匹配`/tmp/php**.tmp`文件



###### 4. game-gyctf web2

反序列化  难度很大，主要是找出序列化的地方，然后找到对应页面，然后还要序列化值传递的参数位置。

``` 
# 要点1 - sql中，可以将列名替换成值，作为输出,这里会输出1 | pwd
select "1","pwd" from user where username = "admin";
# 要点2 - 找到序列化的路径。
User.update() -> UndateHelper.__destruct() -> User.__toString()
-> 这里直接找不到什么类中会执行update(),而这时候还有个类Info没有使用，里面有一个__call方法，是调用不存在的方法的时候会调用，而这个方法存在一个核心方法login,因此接下来 -> Info.__call -> dbCrtl.login
# 要点3 - 直接序列化输入，会被replace方法替换掉，因此需要反序列化字符逃逸


```

